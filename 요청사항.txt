다음은 지금까지 요청하셔서 반영한 작업 정리입니다.

- UI 구조
  - `customtkinter` 기반 전체화면 앱, 탭 구성: 데이터 생성, 화자 선택, 이미지 설정
  - 데이터 섹션 3행: ‘AI 데이터 생성’, ‘AI 데이터 읽기’, ‘설정…’ 버튼 배치
  - 모든 라벨-입력/드롭다운 밀착 배치, 한글 라벨, 밝은/어두운 테마 반영
  - 단일 인스턴스 실행 보장(PID 파일)

- AI 서비스/설정
  - ‘설정…’ 대화창: Gemini API Key/모델/로케일 입력, `.env` 자동 저장/로드
  - `AI Prompt.txt`(우선) → 템플릿 즉시 사용, {{변수}}·[원어]/[학습어]/[등급]/[주제] 등 치환

- 데이터 생성/호출/저장
  - ‘AI 데이터 생성’:
    - 치환된 프롬프트 `..._prompt.txt`/`..._prompt.json` 저장
    - Gemini 호출 → 원문 `..._ai_raw.txt`, 파싱 성공 시 `..._ai.json` 저장
    - 응답 키 정규화(영문 키 → 한국어 표준 키)
    - 표준 키별 스크립트 자동 분리 저장(.txt)
  - ‘AI 데이터 읽기’: 기존 `..._ai.json` 불러 동일한 후처리·분리 저장
  - 메시지 창에 모든 저장/오류 로그 출력

- 스크립트 파일 포맷/매핑(.txt)
  - 회화 스크립트 → `conversation.txt`
  - 타이틀 스크립트 → `title.txt`(리스트 결합)
  - 썸네일 스크립트 → `thumbnail.txt`(text + imageConcept 결합)
  - 인트로 스크립트 → `intro.txt`
  - 엔딩 스크립트 → `ending.txt`
  - 키워드 스크립트 → `keywords.txt`(쉼표 결합)
  - 배경 스크립트 → `background.txt`
  - 대화 스크립트 → `dialogue.txt`
  - 저장 위치: `output/<프로젝트명>/<식별자>/`

- 파싱/후처리
  - `fullVideoScript.dialogueCsv` 사용 시:
    - 한글 비율로 원어/학습어 열 뒤바뀜 자동 감지·교정
    - 헤더를 “순번,원어,학습어,읽기”로 정규화
    - 교정 결과를 ‘회화 스크립트’로도 반영

- 표시 로직(스크립트 탭)
  - 드롭다운 선택 → 대응 `.txt` 우선 로드, 없으면 메모리/자동 로드(ai.json→분리 저장)
  - ‘회화 스크립트’ 선택 시 CSV를 표(그리드)로 렌더링, 나머지는 텍스트 창 표시

- 프리뷰 기능(메시지 창)
  - 로그 라인 더블클릭 → 해당 라인의 경로를 인식해 파일 프리뷰 팝업 표시
  - 경로 없음/파일 없음 시 안내 로그
  - Space 키 프리뷰 바인딩은 제거(요청 반영)

필요 시, 중국어 pinyin → 한글 발음(‘읽기’ 열 자동 변환) 후처리도 추가해 드릴 수 있습니다.

=======

- AI 서비스 설정
  - Gemini: API Key, 모델명(예: gemini-2.5-flash), 로케일

- .env 파일을 사용하도록 수정하고 .env 파일에 어떻게 넣어야하지?

- 실행

- AI 프롬프트가 변하면 다음 실행시 바로 반영되나? 아니면 변경된 내용을 반영해줘

- 실행해줘

- md 파일이 어디에 만들어졌지? 안보이네

- 확인해줘

- 아니 자동으로 저장하게해

- 실행

- @kor-chn_prompt.txt 에 설정값이 만영이 안되어 엉뚱한 내용을 가져왔네. 수정해줘

- 실행

- @fullVideoScript.txt 원어와 학습어가 바뀌었네 확인해줘
  - Nǐ hǎo! Nǐ zěnmeyàng? -> 니하오! 점머양? 이 되야하는데 잘못됐네

- 메시지창에서 저장된 메시지를 선택하고 fn + 스페이스를 누르면 해당 파일을 프리뷰로 볼 수 있게 수정해줘

- 해당 라인을 더블클릭하면 프리뷰하게 해줘

- Space 키와 동일하게 동작하며, 경로가 없거나 파일이 없으면 메시지 창에 안내 로그가 출력됩니다. 삭제

- 실행

- 스크립트 선택과 txt 파일 매칭을 보여줘

- 파일 이름과 스크립트 선택에서 불러오는 파일과 매칭이 안됨

- 회화 스크립트는 그리드 형태로 표시해줘

- 실행

- 지금까지 내가 요청한 작업을 모두 정리해줘

- 내가 요청한 내용을 정리하지 말고 그대로 취합해줘

- 데이터 섹션 3행: ‘AI 데이터 생성’, ‘AI 데이터 읽기’, ‘설정…’ 버튼 배치하고 기능을 구햔해줘

- 버튼이 안보이는데 확인해줘

회화비디오, 인트로 비디오, 엔딩비디오, 대화 비디오를 제작하려는데 어떻게 접근하는 것이 좋을까? 
가장 효율적인 프로세스를 정의하고 정확한 오디오, 비디오 타이밍을 맞추고 비디오를 만들 수 있는 
방법을 제시해줘

다음 프로세스로 가면 정확한 타이밍과 제작 효율을 동시에 잡을 수 있습니다.

### 전체 파이프라인

1. 데이터 표준화
- 회화 CSV(순번, 원어, 학습어, 읽기), 인트로/엔딩/대화 스크립트를 표준 구조로 정리해 
  `timeline_manifest.json`에 저장.
- 장면(Scene) 단위: id, type(intro|conversation|ending), text[], speaker, bg, sfx, transition, notes.
1. 오디오 생성 + 타이밍 확보
- SSML + 마크 사용 권장: 각 재생 단위(문장/어절) 앞에 `<mark name="seg_###"/>` 삽입해 요청.
- Google TTS 요청 시 timepoint 활성화(SSML mark 기준). 응답의 timepoints로 정확한 ms 타임스탬프 획득.
- 마크 미지원/실패 시 대체:
    - 문장 단위로 파일 분할 생성 → `pydub`으로 길이(ms) 측정 → 누적합으로 타임스탬프 생성.
- 화자 간 무음(예: 1.0s)과 학습어 화자 사이 무음(예: 0.5s)을 오디오 타임라인에 삽입.
- 결과물:
    - `output/{proj}/{id}/audio/master.wav|mp3`
    - `output/{proj}/{id}/audio/segments.json`(각 segment의 start_ms/end_ms/voice_name/문장)
1. 자막(SRT/ASS) 생성
- `segments.json`의 start/end_ms로 SRT 생성.
- 한-학습어 2라인 구성 or 색상/스타일 분리(ASS 권장)도 가능.
- 결과물: `captions.srt` 또는 `captions.ass`.
1. 비디오 템플릿 설계
- 템플릿(해상도, 배경, 폰트, 안전영역, 자막 영역) 사전 정의.
- 타입별 권장 템플릿:
    - 인트로: 브랜드/타이틀 + 짧은 SFX + 빠른 인로고
    - 회화 비디오: 배경(사진/영상/그라디언트) + 상단 원어/하단 학습어 + 말하는 동안 키네틱 텍스트
    - 엔딩: 콜투액션 + 아웃로고
    - 대화 비디오(씬 설명 기반): 씬별 배경 전환 + 전환 효과(fade/slide)
1. 렌더 타임라인 합성
- 빠른 구현: moviepy(파이썬 내장)로 오디오 마스터 길이를 기준으로 장면/텍스트를 타임라인에 배치.
- 고성능/정확성: ffmpeg filter_complex 스크립트 생성(자막, 이미지/영상 오버레이, 전환, scale, fps 고정).
- 모든 오버레이 start/end를 `segments.json` 타임스탬프에 맞춤.
1. 산출물
- `intro.mp4`, `conversation.mp4`, `ending.mp4`, `dialogue.mp4`
- `master.mp4`(필요 시 합본)
- `captions.srt/ass`, `timeline_manifest.json`, `audio/segments.json`

### 정확한 타이밍을 위한 핵심 팁

- SSML 마크 기반 타임스탬프가 최선. 문장 또는 어절 단위로 `<mark/>`를 삽입해 말풍선/하이라이트 타이밍에 그대로 사용.
- 무음은 오디오에 실제 삽입하여 영상과 자연 정렬이 되게 함.
- FPS 고정(예: 30fps) 및 오디오 시작 오프셋(0ms) 고정.
- 자막은 오디오 타임라인을 “진실”로 삼고, 비디오 오버레이는 자막과 동일한 start/end로 설정.

### 파일/데이터 예시

- segments.json

```json
{
  "segments": [
    {"id":"n1","speaker":"native","text":"안녕하세요","start_ms":0,"end_ms":1200,"voice":"ko-KR-..."},
    {"id":"sil1","type":"silence","start_ms":1200,"end_ms":2200},
    {"id":"l1","speaker":"learner_1","text":"你好","start_ms":2200,"end_ms":3300,"voice":"cmn-CN-..."}
  ]
}

```

- timeline_manifest.json

```json
{
  "project":"kor-chn","identifier":"kor-chn",
  "scenes":[
    {"id":"intro","type":"intro","bg":"bg/intro.jpg","duration_ms":3000,"text":["타이틀"]},
    {"id":"conv_01","type":"conversation","from_segment":"n1","to_segment":"l1","bg":"bg/scene1.jpg"},
    {"id":"ending","type":"ending","bg":"bg/outro.jpg","duration_ms":2500}
  ]
}

```

### 구현 순서 제안(가장 효율)

- 1 단계: segments.json 생성기 완성
    - SSML 마킹 → 시간표시 수집 → 오디오 마스터/세그먼트 JSON 저장
- 2 단계: 자막 생성기(SRT/ASS)
- 3 단계: moviepy 기반 프로토타입 렌더
    - 배경, 자막, 간단 전환으로 전체 파이프라인 검증
- 4 단계: ffmpeg 스크립트 자동 생성(성능/품질 향상)
    - 하드서브(ASS), 전환효과, 자막 스타일, 스케일링
- 5 단계: 타입별(인트로/회화/엔딩/대화) 템플릿과 스타일 고도화

원하시면 위 순서대로 우리 코드에 `segments.json` 생성과 SRT/ASS 생성부터 바로 넣어드릴게요.

그럼 회화 제작 방식으로 비디오를 만드는 ass 파일을 만드는 과정을 정확하게 만들어줘.
이때 [Styles]의 Format: 은 화자 선택, 이미지 설정의 데이터를 사용하여 만들고,
바탕을 사용하기 위해서는 layer를 사용해야하는데 이를 반영하고
md 파일 내 색상, 폰트, 굵기 등 특정 속성을 반영하게 하는 기능을 반영하는 방법을 만들어줘