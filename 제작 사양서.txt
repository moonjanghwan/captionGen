AI 영상 콘텐츠 제작 자동화 프로그램 제작 사양서 (개선안)

1. 시스템 개요

프로그램명: AI Video Caption Generator
목표: AI를 활용하여 언어 학습용 YouTube 영상 콘텐츠의 기획, 스크립팅, 음성/영상 제작 과정을 자동화하고, 시청자 몰입도를 높이는 고품질의 동적 콘텐츠를 대량 생산하는 데스크톱 애플리케이션입니다.

UI 구성

0. 작성 규칙
    - 모든 타이틀과 입력창은  모두 같은 행에 배치 한다. (예: 원어: Dropbox or CSV 파일: 입력박스)
    - 타이틀과 입력창, 드롭박스는 항상 붙여서 표시한다.
    - 입력창, 드롭박스의 크기는 타이틀(텍스트의 갯수 넓이)의 형식으로 표시한다.
    - 한 행에 있는 것은 모두 좌측으로 정렬한다.
    - 메인 윈도우
        - 크기: 1600x900 픽셀, 중앙에 디스플레이
        - 테마: CustomTkinter 모던 테마
        - 탭 구조: 데이터 소스, 화자 선택, 이미지 설정
        - 바탕색 (전체 배경): #2C3E50 (차콜 블루)
            아주 연한 크림색으로, 눈의 피로를 덜어주고 전체적으로 따뜻한 기반을 만듭니다.
            창, 드롭박스 (입력 요소 배경): #34495E (웻 아스팔트)
            바탕색보다 살짝 깊이감이 있는 부드러운 노란색으로, UI 요소들을 명확히 구분해주면서도 조화를 이룹니다.
            버튼 (클릭 요소):
                기본 상태: #3498DB (피터 리버 블루)
                주의를 끄는 친근한 파스텔 톤의 노란색으로, 사용자가 눌러야 할 요소임을 직관적으로 알 수 있게 합니다.
                눌렸을 때 (Pressed): #5DADE2 (밝은 피터 리버 블루)
                기본 상태보다 채도가 약간 더 높은 색상으로 변경하여, 사용자가 버튼을 눌렀다는 것을 명확하게 인지할 수 있도록 시각적인 피드백을 줍니다.
        - 버튼이 눌리면 색을 바꾸는 등 동작 상황을 알 수 있게 하고 실행이 끝나면 원상 복귀한다.
        - 버튼에 쓰이는 라벨은 가독성이 좋은 색깔을 선택해서 쓴다. 버튼 라벨 색상: #FFFFFF (흰색)
    - 프로그램은 유지보수가 편하고 수정이 편할 정도의 크기로 모듈화 된 프로그램으로 만든다.
    
기술 스택
    1. 프로그래밍 언어 : Python 3.6+
    2. 주요 라이브러리
        - customtkinter: 모던한 GUI 인터페이스
        - google-cloud-texttospeech: Google TTS API 클라이언트
        - 기능	            새로운 권장 방식 (안정적)
        오디오 미리듣기	   subprocess + afplay (macOS 내장)
        오디오 편집       subprocess + FFmpeg (필수 설치)

Sheets로 내보내기

        - pygame: 오디오 재생
        - sounddevice: 실시간 음성 녹음
        - Pillow: 이미지 처리

    3. 외부 API
        - Google Cloud Text-to-Speech API: 음성 합성
        - AI 데이터 생성 엔진: 학습 데이터 자동 생성 
            (gemini-2.5-flash, gemini-2.5-pro 모델 선택하도록 구성)

0. 메뉴 구성 방법

    메뉴 구성 방법 : 바탕색(10) 입력창,텍스트 행수(4) Dropbox, 구간(5) 체크박스 와 같은 형식은 
            라벨(크기: 글자 수), 입력창 이나 Dropbox, 체크박스 구분의 형태로 만들어줘
    메뉴버튼을 선택을 하면 선택된 메뉴 버튼은 다른 칼라로 선택 된 것을 표시 해줘야 돼

1. 데이터 생성 메뉴 : 4개의 섹션으로 구성 한다.위에서 아래로 구성한다.
    1.1. 데이터 섹션     
        1행 : '원어'(20), '학습어'(20) Dropbox, '프로젝트명' : 입력창(20), '식별자': 입력창(20)
            원어 : 배우는 사람이 쓰는 언어, 학습어 : 배울 언어
        2행 : '학습 주제'(20) Dropbox, '직접 주제를 입력하세요'(50), '등급'(15) Dropbox,'데이터 개수'(3) Dropbox
        3행: 'AI 서비스'(20) Dropbox, 'AI 데이터 생성' 버튼, '데이터 읽기' 버튼

    1.2. 스크립트 섹션
        - '스크립트 선택:' (30) Dropbox
            회화 스크립트, 타이틀 스크립트, 썸네일 스크립트, 인트로 스크립트,
            엔딩 스크립트, 키워드 스크립트, 배경 스크립트, 대화 스크립트 항목으로 구성되어 있다.
        - 스크립트 창: 스크립트 창에는 '스크립트 선택'에서 선택된 스크립트를 디스플레이 한다. (높이를 2배로 확대)
        - 스크립트는 MD 형식의 텍스트나 CSV 파일로 되어있고 스크립트 창에서 수정할 수 있다.
    

    1.3. 메시지 윈도우
        - 실행중인 프로세스의 진행 상태, 에러메시지 등을 표시하는 창 (높이를 2배로 확대)

    1.4. 콘트롤 버튼 섹션
        - 오디오 생성: 스크립트 전체의 TTS 오디오 파일(.mp3)을 생성합니다.
        - 오디오 듣기: 선택된 스크립트 라인을 TTS로 실시간 재생하여 확인합니다.
        - 썸네일 생성: '썸네일 설정' 탭의 디자인에 따라 썸네일 이미지를 생성합니다.
        - 회화 비디오: 회화 스크립트, 생성된 오디오, '이미지 설정'을 종합하여 회화 영상을 만듭니다.
        - 인트로 비디오: 인트로 스크립트로 각각의 영상을 만듭니다.
        - 엔딩 비디오: 엔딩 스크립트로 각각의 영상을 만듭니다.
        - 대화 비디오: 내레이터와 학습자 간의 대화 형식으로 구성된 별도의 영상을 제작합니다.
        - 정지 버튼: 현재 실행 중인 모든 백그라운드 작업(오디오/비디오 생성, TTS 미리 듣기 등)을 즉시 강제 중단합니다.
        - 종료 버튼: 애플리케이션을 안전하게 종료합니다. 
            변경 후 저장되지 않은 내용이 있을 경우 저장합니다.
        밑에 한줄로 배치한다.

2. 화자 선택 메뉴 : 원어 화자와 학습어 화자를 선택한다.
    2.1. 화면 구성
        - 원어 화자:
            화자 선택 드롭박스(50), 미리듣기 버튼
        - 학습어 화자:
            화자 수 : 학습어 화자 수(6) Dropbox (Default 값 = 4) (수에 따라 학습어 화자의 행이 표시 된다)
                    크기는 세 글자 들어갈 정도의 크기
            학습어 1 선택 드롭박스(50), 미리 듣기 버튼
            학습어 2 선택 드롭박스(50), 미리 듣기 버튼
            학습어 3 선택 드롭박스(50), 미리 듣기 버튼
            학습어 4 선택 드롭박스(50), 미리 듣기 버튼
        각각의 화자와 화자 수는 줄을 맞춰서 정렬 해서 디스플레이 한다.
        - 화자 설정 저장 버튼
            출력 경로: './output/{프로젝트명}/{식별자}/speaker.json로 설정 파일을 저장한다.
            프로그램이 실행할 때는 프로젝트에 맞는 speaker 설정 파일을 읽어온다.

3. 이미지 설정 메뉴

    - 이미지 설정의 UI는 4개의 섹션으로 구성하고 공통 설정, 텍스트 설정, 메시지 창, 콘트롤 섹션으로 구성한다.
 
    3.1. 공통 설정 섹션 (배경 설정 섹션)
        1행: '배경 설정:' 텍스트, '색상','이미지','동영상' (라디오 버튼), 배경값(15) 입력창, '찾아보기' 버튼
            라디오 버튼 선택에 따라 다음과 같이 처리 한다
                색상 : 배경칼라 선택 (칼라) Default = #000000
                이미지 : 배경 이미지 선택 (jpg, png)
                비디오 : 배경 비디오 선택 (mp4)
                찾아 보기 버튼은 이미지일 경우에는 JPG 나 PNG, 동영상일 경우는 MP4 파일을 검색 하게 한다.
            라디오 버튼의 선택에 따라서 입력창에는 해당 데이타를 입력 할 수 있도록 한다
        2행: '바탕 설정:' 텍스트,  구간(5) 체크박스 Default = False,바탕색(15) 입력창 Default = #000000,
            투명도(10) 입력창 Default = 1.0, 여백(10) Dropbox Default = 2
        3행: '쉐도우 설정:' 텍스트, 두께(6) 입력창 Default = 2, 쉐도우 색상(10) 입력창 Default = #000000,
        4행: '외곽선 설정:' 텍스트, 두께(6) 입력창 Default = 2, 외곽선 색상(10) 입력창 Default = #000000   
        
        2행에서 체크박스 구간은 선택(True)이 될 경우에는 텍스트라인 전체 x,y,xw,xh를 바탕으로 사용하는 형태로 동작 한다.
            False일 경우에는 텍스트 에만 바탕이 생성 된다.
        미리보기 나 비디오 생성에서 이미지를 만들 때는 바탕 설정, 쉐도우 설정,외곽선 설정의 체크박스에 따라 비디오 생성에 반영 한다.

    3.2. 텍스트 설정
        - '회화 설정', '썸네일 설정','인트로 설정', '엔딩 설정', '대화 설정'의 5개 탭으로 구성 되있다.
        - 텍스트 행수(8) Dropbox Default = 4, 화면비율(16) Dropbox Default = 16:9, 
                해상도(16)Dropbox  Default = 1920 X 1080
        - 타이틀은 행, x, y, w, 크기(pt),폰트(pt),색상,굵기,좌우 정렬,상하 정렬로 구성하고 입력창과 Dropbox의 중앙 절렬한다.
        - 각 행의 크기는 다음과 같고 위젯의 데이터는 중앙 정렬한다.
            행(10) 텍스트, x(6) 입력창, y(6)입력창, w(6)입력창, 크기(pt)(6)입력창,
            폰트(pt)(30) Dropbox,색상(10) 입력창,
            굵기(10) Dropbox,좌우 정렬(10) Dropbox,상하 정렬(10) Dropbox 
        - 설정 값 : 
            '폰트(pt)' Dropbox는 시스템에서 제공하는 Noto Sans KR, KoPubWorld돋움체, KoPubWorld바탕체 설정
            '굵기' : 폰트 Dropbox는  weight (Light, Medium, Bold)로 설정
        - 라벨과 입력창, Dropbox는 최소한의 갭을 두고 붙여서 표시한다.
        - 위젯 안의 데이터는 중앙 정렬한다.

        Default 값

        - 회화 설정     텍스트 행수(6) Dropbox Default = 4
            행, x, y, w, 크기(px),폰트(pt),색상,굵기,좌우 정렬,상하 정렬, 바탕설정(10) 체크박스,  쉐도우 설정(10) 체크박스, 외곽선 설정(10) 체크박스 
            순번, 50, 50, 1820, 80, KoPubWorldDotum, #FFFFFF, Bold, Left, Top, False, False,False
            원어, 50, 150, 1820, 100, KoPubWorldDotum, #00FFFF, Bold, Center, Top, False, False,False
            학습어, 50, 450, 1820, 100, Noto Sans Gothic, #FF00FF, Bold, Center, Top, False, False,False
            읽기, 50, 750, 1820, 100, KoPubWorldDotum, #FFFF00, Bold, Center, Top, False, False,False

        - 썸네일 설정     텍스트 행수(6) Dropbox Default = 4
            행, x, y, w, 크기(px),폰트(pt),색상,굵기,좌우 정렬,상하 정렬, 바탕설정(10) 체크박스,  쉐도우 설정(10) 체크박스, 외곽선 설정(10) 체크박스 
            1행, 50, 50, 924, 100, KoPubWorldDotum, #FFFFFF, Bold, Left, Top, False, False,False
            2행, 50, 200, 924, 100, KoPubWorldDotum, #00FFFF, Bold, Left, Top, False, False,False
            3행, 50, 350, 924, 100, KoPubWorldDotum, #FF00FF, Bold, Left, Top, False, False,False
            4행, 50, 500, 924, 100, KoPubWorldDotum, #FFFF00, Bold, Left, Top, False, False,False


        - 인트로 설정     텍스트 행수(6) Dropbox Default = 1
            행, x, y, w, 크기(px),폰트(pt),색상,굵기,좌우 정렬,상하 정렬, 바탕설정(10) 체크박스,  쉐도우 설정(10) 체크박스, 외곽선 설정(10) 체크박스 
            1행, 50, 50, 80, 1820, KoPubWorldDotum, #FFFFFF, Bold, Left, Top, False, False ,False
            

        - 엔딩 설정     텍스트 행수(6) Dropbox Default = 1
            행, x, y, w, 크기(px),폰트(pt),색상,굵기,좌우 정렬,상하 정렬, 바탕설정(10) 체크박스,  쉐도우 설정(10) 체크박스, 외곽선 설정(10) 체크박스 
            1행, 50, 50, 1820, 100, KoPubWorldDotum, #FFFFFF, Bold, Left, Top, False, False,False

        - 대화 설정     텍스트 행수(6) Dropbox Default = 3
            행, x, y, w, 크기(px),폰트(pt),색상,굵기,좌우 정렬,상하 정렬, 바탕설정(10) 체크박스,  쉐도우 설정(10) 체크박스, 외곽선 설정(10) 체크박스 
            원어, 50, 250, 1820, 100, KoPubWorldDotum, #FFFFFF, Bold, Left, Top, False, False,False
            학습어1, 50, 550, 1820, 100, KoPubWorldDotum, #FFFFFF, Bold, Left, Top, False, False,False
            학습어2, 50, 850, 1820, 100, KoPubWorldDotum, #FFFFFF, Bold, Left, Top, False, False,False
   
    3.3 메시지 창 섹션
        현재 UI에 설정된 모든 디자인 값을 JSON 형식 또는 읽기 

    3.4 콘트롤 버튼 섹션
        - '미리보기' 버튼 : (좌측에 배치) 선택된 스크립트의 png 파일을 생성한다.
        - '비디오 생성' 버튼 : (좌측에 배치) 선택된 스크립트의 비디오를 생성한다.
        - '설정 저장' 버튼: (우측에 배치)정의된 모든 데이터를 저장
        - '설정 읽기' 버튼: (우측에 배치)저장된 데이터를 불러와 모든 UI 컨트롤에 값을 복원하여, 일관된 디자인 템플릿을 재사용할 수 있다.



프로그램 실행시 전에 실행된 파일이 있으면 그 프로그램을 죽이고 실행한다.




동작 방법

0. 초기화
    - google TTS 연결 (메시지 출력)
        Google TTS에서 지원하는 언어 목록을 동적으로 가져오기
        Google TTS API 인증
    - gemini 2.5 flash 인증 연결 (메시지 출력)

1. 프로젝트 설정
    
    - 언어 페어 : 원어, 학습어 선택 드롭박스에 다음의 지원언어에서 선택하게한다.
        지원 언어
            - 한국어 (ko-KR):
            - 영어: en-US
            - 일본어 (ja-JP)
            - 중국어: cmn-CN
            - 베트남어 (vi-VN)
            - 인도네시아어 (id-ID)
            - 이탈리아어 (it-IT)
            - 스페인어 (es-US)
            - 프랑스어 (fr-FR)
            - 독일어 (de-DE)
    - 프로젝트 명: kor-jan과 같이 [3자리 국가명]-[3자리 국가명] 형식으로 자동 생성됩니다.
    - 식별자: kor-jan과 같이 [3자리 국가명]-[3자리 국가명] 형식으로 자동 생성됩니다.
    - 프로그램이 종료 될 때 실행 프로젝트를 저장했다가 프로그램이 다시 시작할 때 다시 프로젝트명, 식별자와 
      언어 페어로 세팅 한다.
    - 언어 페어가 바뀌거나 '화자 선택' 탭이 선택 되면 선택된 국가의 화자를 선택할 수 있도록 한다.

    - 출력 경로: './output/{프로젝트명}/{식별자}/'에 .json, .csv, .mp3, .mp4, .jpg 
        파일을 {식별자} 이름으로 저장한다.
        
2. 데이타 생성 탭
    - AI 데이터 생성
        - 텍스트 영역학습 주제를 선택 한다.
        - 생성할 스크립트의 톤앤매너, 특정 단어 포함 등 세부 조건을 입력하는 경우에는 추가 요구사항에 입력 한다.
        - 필요시 AI 서비스를 선택한다. gemini-2.5-flash(Default), gemini-2.5-pro
        - 학습 등급을 선택한다.
        - 생성 할 데이터 개수를 입력 한다. Default = 5
        - 'AI 데이터 생성' 버튼을 누른다.
            - 입력 된 데이터를 사용하여 AI Prompt.txt 파일에 위에서 입력된 '주제', '추가 요구사항', '등급', '개수'를 입력하여
            AI 프롬프트를 만들어서 AI에게 데이터 생성을 요청 한다.
            이때 만들어진 prompt 파일을 ./output/{프로젝트명}/{식별자} 폴더에 {식별자}_prompt.txt 파일로 저장한다. (디버깅을 위해)
            - AI가 출력한 JSON 파일을 ./output/{프로젝트명}/{식별자} 폴더에 {식별자}_ai.json으로 저장한다.
            - 출력 된 json 파일을 파싱하여 해당 스크립트 데이터 창에 입력 하고 스크립트 별로 해당 파일명.txt 파일로 
                ./output/{프로젝트명}/{식별자} 폴더에 저장한다.
            
    - '데이터 읽기' 버튼 : 
        ./output/{프로젝트명}/{식별자} 폴더에 {식별자}_ai.json 파일이 있으면 
        {식별자}_ai.json 파일을 파싱하여 해당 스크립트 데이터 창에 입력 한다.
        읽은 후에는 '오디오 생성', '오디오 듣기' 버튼이 활성화 된다.
        회화 스크립트에서 csv 파일을 읽을 때 문장 내에 ','가 있을 때 문장이 나누어지는 경우가 있는데, 
        일을 해결해줘
        
    - '스크립트 선택'을 선택하면 선택된 데이터를 데이터창에 디스플레이하고 오디오 생성, 
        오디오 듣기 버튼이 활성화 되어야한다.
        - 회화 스크립트 창 : 읽어온 CSV 파일을 그리드 형식으로 표시한다.
        - 인트로/ 엔딩 스크립트 창 : 문장 단위로 줄바꿈을 한다.
    
    - 오디오 생성
        1. 회화 오디오 생성
            회화 스크립트 창에서 데이터를 한 행씩 가져와서 오디오를 실시간 생성한다.
            화자 : 원어화자, 학습어 화자 1,2,3,4 
            대화 순번 : 다음과 같이 재생하며 화자간에는 1초의 무음을 넣어준다.
                1. 원어화자 - 원어
                2. 학습어 화자 1 - 학습어
                3. 학습어 화자 2 - 학습어
                4. 학습어 화자 3 - 학습어
                3. 학습어 화자 4 (1 원어, 4 학습어)
            화자간에는 1초의 무음을 넣는다.
            전체 행을 mp3로 만든다.
            SSML `<mark>` 태그를 사용하여 정확한 타이밍이 있는 '오디오 생성'과 
                같은 방법으로 mp3 파일을 만든다.
            이때 만들어진 mp3 파일을 ./output/{프로젝트명}/{식별자}/mp3 폴더에 {식별자}_conversation.mp3 파일로 저장한다.
            이때 만들어진 SSML 파일을 ./output/{프로젝트명}/{식별자}/SSML 폴더에 {식별자}_conversation.ssml 파일로 저장한다.
        2. 인트로/엔딩 오디오 생성
            인트로/엔딩 스크립트 창에서 데이터를 한 문장씩 가져와서 오디오를 실시간 생성한다.
            화자 : 원어화자
            문장 간에는 1초의 무음을 넣는다.
            전체 문장을 mp3로 만든다.
            SSML `<mark>` 태그를 사용하여 정확한 타이밍이 있는 '오디오 생성'과 
                같은 방법으로 mp3 파일을 만든다.
            이때 만들어진 mp3 파일을 ./output/{프로젝트명}/{식별자}/mp3 폴더에 {식별자}_intro.mp3,{식별자}_ending.mp3 파일로 저장한다.
            이때 만들어진 SSML 파일을 ./output/{프로젝트명}/{식별자}/SSML 폴더에 {식별자}_intro.ssml, {식별자}_ending.ssml 파일로 저장한다.


    - 오디오 듣기 conversation
        화자 : 원어화자, 학습어 화자 1,2,3,4 
        대화 순번 : 원어화자, 학습어 화자 1, 학습어 화자 2, 학습어 화자 3, 학습어 화자 4 (1 원어, 4 학습어)순서로 읽기
        읽는 순서 :  각 행별로 다음 순서로 읽고 전체 행을 읽는다.
            원어 화자 : 원어 화자(원어 텍스트), 학습어 화자 1 (학습어 텍스트), 학습어 화자 2 (학습어 텍스트), 
            학습어 화자 3(학습어 텍스트), 학습어 화자 4(학습어 텍스트) 순으로 실시간으로 읽는다.
        각 행별로 원어 화자 및 4명의 학습어 화자(총 5명)에 대해 Google TTS를 호출하는 로직을 구현합니다.
        실시간 듣기로 오디오 재생한다.
        각 화자 오디오 클립 사이에 1초 무음을 포함하여 연결하는 로직을 구현합니다.
        

    - '회화 비디오' 
        각 행별로 2개의 독립적인 텍스트 화면을 생성하는 로직을 구현합니다.
        사전에 다음과 같이 png 자막 파일을 만든다. 이때 배경은 칼라로하고 #000000 색으로 한다.
            화면 1: 순번, 원어 텍스트만 화면에 표시한다.
            화면 2: 순번, 원어, 학습어, 읽기를 화면에 표시한다.
        각 화자간, 각 행간에는 무음 1초를 삽입한다.

        SSML `<mark>` 태그를 사용하여 정확한 타이밍이 있는 '오디오 생성'과 같은 방법으로 mp3 파일을 만든다.

        타이밍과 자막 매칭 방법
            화자 : 원어화자, 학습어 화자 1,2,3,4 
            대화 순번 : 다음과 같이 재생하며 화자간, 행간에는 1초의 무음을 넣어준다.
                1. 원어화자 - 원어             화면 1   원어 화자 시작 시간 ~ 종료 시간
                2. 학습어 화자 1 - 학습어       화면 2   학습어 화자 1 시작 시간 ~ 학습어 화자 4 종료시간
                3. 학습어 화자 2 - 학습어       화면 2
                4. 학습어 화자 3 - 학습어       화면 2
                3. 학습어 화자 4 - 학습어       화면 2

        오디오, 자막, 배경을 이용하여 렌더링을 하여 mp4 파일을 만든다.
        
       

    - '인트로 비디오', '엔딩 비디오' 버튼
        문장 단위로 인트로/ 엔딩 스크립트를 읽어 자막을 만들며, 자막의 길이가 길어서 화변 밖으로 나가면 스마트 문장 분리로
        최대 3줄 까지 만든다.
        이때 배경은 칼라로하고 #000000 색으로 한다.

        자막은 x, y(좌상위치)을 w(넓이)를 기준으로 줄 수에 따라 위에서 아래로 쓰며, 
            마지막 줄이 항상 x, y값을 마지막 줄의 좌상 값으로 한다.   
        문장은 md 속성으로 문장안에 칼라, 굵기 등 속성을 처리할 수 있게 한다.
        
        SSML `<mark>` 태그를 사용하여 정확한 타이밍이 있는 mp3 파일을 만든다.
        
        오디오, 자막, 배경을 이용하여 렌더링을 하여 mp4 파일을 만든다.
    
    
    '대화 비디오' 버튼
        - 대화문은 내레이터, 화자 1,2 등 정해준 화자로 정해진 위치에 표시하고, 화자 수 만큼 반복해서 읽고
            자막은 화자 1의 시작 시간부터 화자 n의 종료 시간 까지 유지한다.
        - 내레이터가 없으면 화자의 내레이션만 사용한다.

        
    - '정지' 버튼: 현재 실행 중인 모든 백그라운드 작업(오디오/비디오 생성, TTS 미리 듣기 등)을 즉시 강제 중단합니다.

    - '종료' 버튼: 애플리케이션을 안전하게 종료합니다. 변경 후 저장되지 않은 내용이 있을 경우 저장합니다.

3. 화자 선택 탭
    - 오디오 제작에 필요 '원어'(또는 내레이터) '학습어 화자수'를 선택하면 필요한 
        학습어 수(Default 4)만큼을 입력 할 수 있는 행이 만들어진다.
    - '원어', '학습어 화자'의 언어 선택은 기본적으로 '데이터 생성' 탭에서 입력 된 언어 페어('원어', '학습어')를 사용하여 
        자동으로 언어가 선택이 되도록 한다.
    - 자동 선택된 언어의 화자를 Google TTS에서 제공하는 해당 언어의 
        모든 화자가 디스플레이 되도록 한다.
    - '화자 설정 저장'버튼
        - 선택된 모든 화자를 저장하고, '화자 선택' 탭이 눌렀을 경우에는 저장된 데이터가 있으면 
        저장된 데이터를 자동으로 읽어 온다.
        - 화자 설정 JSON 파일을 ./output/{프로젝트명}/{식별자} 폴더에 {식별자}_speaker.json으로 저장한다.
    - '미리듣기' 버튼
        - '미리 듣기'는 '원어', '학습어' 화자 국가의 발음으로 미리듣기를 한다.

4. 이미지 설정 탭
    - 이미지 설정의 UI는 3개의 섹션으로 구성하고 공통 설정, 텍스트 설정, 메시지 창으로 구성한다.
    - 공통 설정 섹션은 
        화면 비율, 해상도
        배경 설정: 색상,이미지,동영상, 입력창
        바탕 설정: 바탕색,투명도,여백
        쉐도우 설정: 두께, 쉐도우 색상 
        외곽선 설정: 두께, 외곽선 색상
    - 텍스트 설정 섹션은 
        회화,썸네일,인트로,엔딩,스크립트의 탭으로 구성 된다.
        각 탭은 텍스트의 위치를 지정 하는 텍스트 설정
        각 탭은 텍스트 행 수를 입력받아 텍스트의 위치를 정하는 행을 표시한다.
        행은 타이틀은 행, x, y, w, 크기(px),폰트(pt),색상,굵기,좌우 정렬,상하 정렬로 구성 된다.
        x = x_pos, y = y_pos, w = width
        회화 탭의 행 이름 : 순번, 원어, 학습어, 읽기
        썸네일 탭, 인트로 탭, 엔딩, 스크립트 탭의 행 이름 : 1행, 2행, 3행, 4행
    - 메시지 창 섹션
        현재 UI에 설정된 모든 디자인 값을 JSON 형식 또는 읽기 

    - '자막 이미지 생성' 버튼

        png 파일을 만든다.
        각 설정 탭에 따라 다음과 같이 동작한다.
        각 텍스트의 속성은 텍스트 설정에 있는 모든 설정 값을 반영하여 텍스트를 생성 한다.
        이미지 설정 탭에서 정리된 설정 값을 반영하여 이미지를 만듭니다.
        파일을 ./output/{프로젝트명}/{식별자} 폴더에 dialog, thumbnail, intro, ending 폴더를 만들어 
            번호를 붙여 {식별자}_001.png의 형식으로 저장한다.

        1. 회화 이미지 생성 : 
            각 행별로 2개의 독립적인 텍스트 화면을 생성하는 로직을 구현합니다.
            화면 1: 순번, 원어 텍스트만 화면에 표시한다.
            화면 2: 순번, 원어, 학습어, 읽기를 화면에 표시한다.
            이미지 생성시 회화 설정에 설정된 데이터를 사용한다.

        2. 썸네일 이미지 생성
            AI 생성 JSON 파일을 읽어 파싱하여 썸네일 문장을 추출하여 사용한다.
            4줄의 텍스트를 읽어 이미지 파일을 만든다. 이떄 읽은 값을 터미널에 출력한다.
            주어진 3 세트를 이미지로 만든다.
            이미지 생성시 썸네일 설정에 설정된 데이터를 사용한다.
            텍스트가 w를 넘는 경우 적당히 폰트사이즈를 줄여 텍스트를 만든다.

        3. 인트로 이미지 생성
            AI 생성 JSON 파일을 읽어 파싱하여 인트로 스크립트를 사용한다.
            문장별로 읽어 문장일 길어 w를 넘으면 스마트 줄바꿈을 하고 상하 정렬이 
                top : x,y를 기준으로 화면 아래로 텍스트를 쓴다.
                bottom : x, y가 마지막 줄의 기준이고 그 위로 줄을 쓴다.
            스크립트 전체 문장을 이미지로 만든다.

        4. 엔딩 이미지 생성    
            인트로 스크립트를 사용한다.md 인라인 스크립트로 텍스트의 속성을 변경한다.
            문장별로 읽어 문장일 길어 w를 넘으면 스마트 줄바꿈을 하고 상하 정렬이 
                top : x,y를 기준으로 화면 아래로 텍스트를 쓴다.
                bottom : x, y가 마지막 줄의 기준이고 그 위로 줄을 쓴다.
            스크립트 전체 문장을 이미지로 만든다.

        5. 대화 설정 : 추후 정의

    - 설정 저장    
        - 정의된 모든 데이터를 저장
    - 설정 읽기
        - 저장된 데이터를 불러와 모든 UI 컨트롤에 값을 복원하여, 일관된 디자인 템플릿을 재사용할 수 있다.





====================
5. 파이프라인	
====================


 최종 제안: Manifest 기반 동적 비디오 자동 생성 파이프라인 (v3 - 최종 구현안)

  이 문서는 timeline_manifest.json을 중심으로, 현재 프로젝트 구조에 맞춰 최종 비디오를 출력하기까지의 모든 과정과 각 핵심 모듈의 전체 구현 코드 예시를 포함한 최종
  실행 계획입니다.

  [1단계] 비디오 구조 설계 (Timeline Manifest)

  모든 제작 과정은 아래 timeline_manifest.json 파일 하나로 제어됩니다. 이 파일을 프로젝트 루트에 생성하거나, UI를 통해 생성/관리하게 됩니다.

  `timeline_manifest.json` (최종 예시)

    1 {
    2   "project_name": "Effective Communication Ep.1",
    3   "resolution": "1920x1080",
    4   "default_background": "assets/bg_main.mp4",
    5   "scenes": [
    6     {
    7       "id": "intro_01",
    8       "type": "intro",
    9       "content": {
   10         "script": "안녕하세요! **효과적인 커뮤니케이션** 시리즈에 오신 것을 환영합니다. 오늘은 *[color=#00FFFF]경청의 중요성[/color]*에 대해 알아봅니다."
   11       }
   12     },
   13     {
   14       "id": "dialogue_01",
   15       "type": "dialogue",
   16       "background": "assets/bg_interview.jpg",
   17       "content": {
   18         "script": [
   19           { "speaker": "A", "text": "어제 보낸 파일 확인하셨나요?" },
   20           { "speaker": "B", "text": "네, 지금 막 확인했습니다. 몇 가지 질문이 있어요." }
   21         ]
   22       }
   23     },
   24     {
   25       "id": "conversation_01",
   26       "type": "conversation",
   27       "content": {
   28         "sequence": 1,
   29         "native_script": "Let's get started.",
   30         "learning_script": "시작해 봅시다.",
   31         "reading_script": "Si-jak-hae bop-si-da."
   32       }
   33     },
   34     {
   35       "id": "ending_01",
   36       "type": "ending",
   37       "content": {
   38         "script": "시청해주셔서 감사합니다. [size=110]**구독과 좋아요**[/size]를 잊지 마세요!"
   39       }
   40     }
   41   ]
   42 }

  ---

  [2단계] 오디오 및 타임스탬프 생성

  위 Manifest를 기반으로, 2단계 파이프라인을 실행하면 다음과 같은 타임스탬프 파일이 생성됩니다.

  `{identifier}_segments.json` (생성 예시)

    1 {
    2   "intro_01_seg_0": { "start": 0.5, "end": 3.2 },
    3   "intro_01_seg_1": { "start": 3.8, "end": 5.1 },
    4   "dialogue_01_A_0": { "start": 5.6, "end": 7.1 },
    5   "dialogue_01_B_0": { "start": 7.5, "end": 9.8 },
    6   "conversation_01_native": { "start": 10.2, "end": 11.0 },
    7   "conversation_01_learning_0": { "start": 12.0, "end": 13.1 },
    8   "conversation_01_learning_1": { "start": 14.1, "end": 15.2 },
    9   "conversation_01_learning_2": { "start": 16.2, "end": 17.3 },
   10   "conversation_01_learning_3": { "start": 18.3, "end": 19.4 },
   11   "ending_01_seg_0": { "start": 20.0, "end": 22.5 }
   12 }

  ---

  [3단계] 핵심 모듈 코드 구현

  아래 내용은 제안서에 따라 수정될 각 핵심 파일의 전체 코드입니다. 이대로 각 파일을 수정하거나 생성하면 됩니다.

  1. `src/ui/ui_utils.py` (신규 생성)
  UI 위젯 생성을 표준화하기 위한 유틸리티 함수입니다.

    1 import customtkinter as ctk
    2 from src import config
    3 import tkinter as tk
    4
    5 def create_labeled_widget(p, label_text, char_width, widget_type="entry", widget_params=None):
    6     frame = ctk.CTkFrame(p, fg_color="transparent")
    7     ctk.CTkLabel(frame, text=f"{label_text}:").pack(side="left", padx=(0, 3), pady=5)
    8     pixel_width = char_width * 9
    9     if pixel_width < 80 and widget_type in ["combo", "dropbox"]:
   10         pixel_width = 80
   11
   12     widget_params = widget_params or {}
   13     if 'fg_color' not in widget_params:
   14         widget_params['fg_color'] = config.COLOR_THEME["widget"]
   15     if 'text_color' not in widget_params:
   16         widget_params['text_color'] = config.COLOR_THEME["text"]
   17
   18     widget = None
   19     if widget_type.lower() in ["combo", "dropbox"]:
   20         widget = ctk.CTkComboBox(frame, width=pixel_width, **widget_params)
   21     elif widget_type.lower() == "checkbox":
   22         widget = ctk.CTkCheckBox(frame, text="", **widget_params)
   23     else:
   24         widget = ctk.CTkEntry(frame, width=pixel_width, **widget_params)
   25
   26     widget.pack(side="left", pady=5)
   27     frame.pack(side="left", padx=(0,10))
   28     return frame, widget

  2. `src/pipeline/subtitle/text_renderer.py` (수정)
  인라인 스타일링, 스마트 줄바꿈, 동적 설정 적용 로직이 포함됩니다.

    1 import os
    2 import re
    3 from typing import Dict, Any, Optional, Tuple, List
    4 from PIL import Image, ImageDraw, ImageFont
    5 import textwrap
    6 from src import config
    7
    8 class TextRenderer:
    9     def __init__(self, settings: Dict[str, Any]):
   10         self.config = self._load_config(settings)
   11         self.fonts = {}
   12
   13     def _load_config(self, settings: Dict[str, Any]) -> Dict[str, Any]:
   14         default_config = {
   15             "fonts": {
   16                 "Noto Sans KR": "~/Library/Fonts/NotoSansKR-Regular.ttf",
   17                 "KoPubWorld돋움체": "~/Library/Fonts/KoPubWorld Dotum Medium.ttf",
   18                 "KoPubWorld바탕체": "~/Library/Fonts/KoPubWorld Batang Medium.ttf"
   19             }
   20         }
   21         self._merge_configs(default_config, settings)
   22         return default_config
   23
   24     def _merge_configs(self, base, user):
   25         for key, value in user.items():
   26             if key in base and isinstance(base[key], dict) and isinstance(value, dict):
   27                 self._merge_configs(base[key], value)
   28             else:
   29                 base[key] = value
   30
   31     def _get_font(self, font_name: str, size: int) -> ImageFont.FreeTypeFont:
   32         if font_name in self.fonts:
   33             return ImageFont.truetype(self.fonts[font_name], size)
   34
   35         font_path = self.config.get("fonts", {}).get(font_name)
   36         if font_path:
   37             font_path = os.path.expanduser(font_path)
   38             if os.path.exists(font_path):
   39                 self.fonts[font_name] = font_path
   40                 return ImageFont.truetype(font_path, size)
   41
   42         print(f"⚠️ 폰트 파일을 찾을 수 없습니다:{font_name}. 기본 폰트를 사용합니다.")
   43         return ImageFont.load_default()
   44
   45     def render_styled_text(self, draw: ImageDraw.ImageDraw, text_segments: List[Dict], x: int, y: int, settings: Dict):
   46         current_x = x
   47         for segment in text_segments:
   48             text = segment.get("text", "")
   49             font_name = segment.get("font", settings.get("폰트(pt)"))
   50             size = int(segment.get("size", settings.get("크기(pt)", 48)))
   51             color = segment.get("color", settings.get("색상", "#FFFFFF"))
   52
   53             font = self._get_font(font_name, size)
   54             draw.text((current_x, y), text, font=font, fill=color)
   55             current_x += draw.textbbox((0,0), text, font=font)[2]
   56
   57     def render_multiline_text(self, lines: List[str], width: int, height: int, line_settings: List[Dict]):
   58         # ... (이전 제안서의 `render_multiline_text` 구현) ...
   59         # 이 부분은 스타일 조각을 처리하도록 `render_styled_text`를 호출하는 로직으로 변경됩니다.
   60         pass # 상세 구현은 생략
   61
   62     # ... conversation, intro, ending 렌더링 메서드들 ...

  3. `src/pipeline/subtitle/generator.py` (수정)
  Manifest와 설정을 받아 TextRenderer를 제어합니다.

    1 import os
    2 from typing import Dict, Any, Optional, List
    3 from .text_renderer import TextRenderer
    4
    5 class SubtitleGenerator:
    6     def __init__(self, settings: Dict[str, Any], identifier: str):
    7         self.text_renderer = TextRenderer(settings)
    8         self.identifier = identifier
    9         self.frames = []
   10         self.output_dir = ""
   11         self.resolution = (1920, 1080)
   12
   13     def generate_from_manifest(self, manifest_data: Dict, output_dir: str):
   14         # ...
   15         # scene type에 따라 _generate_..._frames 메서드 호출
   16         pass
   17
   18     def _generate_intro_frames(self, scene: Dict, start_frame: int, fps: int):
   19         # 1. 스크립트에서 스타일 파싱
   20         # 2. textwrap으로 스마트 줄바꿈
   21         # 3. TextRenderer 호출하여 이미지 생성
   22         # 4. 파일 저장: os.path.join(self.output_dir, f"{self.identifier}_{start_frame:03d}.png")
   23         pass
   24
   25     # ... conversation, ending, dialogue 프레임 생성 메서드들 ...

  4. `src/pipeline/ffmpeg/renderer.py` (신규 또는 수정)
  모든 에셋을 최종 비디오로 결합합니다.

    1 import ffmpeg
    2
    3 class FFmpegRenderer:
    4     def render_video(self, manifest: Dict, segments: Dict, master_audio_path: str, image_sequence_paths: Dict):
    5         bg_path = manifest.get("default_background")
    6         resolution = manifest.get("resolution", "1920x1080").split('x')
    7         width, height = int(resolution[0]), int(resolution[1])
    8
    9         video_stream = ffmpeg.input(bg_path, loop=1, t=segments['total_duration'])
   10         audio_stream = ffmpeg.input(master_audio_path)
   11
   12         for scene_id, scene_images in image_sequence_paths.items():
   13             for img_info in scene_images:
   14                 img_path = img_info['path']
   15                 start = img_info['start']
   16                 end = img_info['end']
   17                 subtitle_stream = ffmpeg.input(img_path)
   18                 video_stream = video_stream.overlay(subtitle_stream, enable=f'between(t,{start},{end})')
   19
   20         output_path = f"./output/{manifest['project_name']}_final.mp4"
   21         (
   22             ffmpeg
   23             .output(video_stream, audio_stream, output_path, vcodec='libx264', acodec='aac', strict='experimental', shortest=None)
   24             .run(overwrite_output=True)
   25         )
   26         print(f"✅ 최종 비디오 생성 완료: {output_path}")

  ---

  [4단계] 실행 및 검증

  위와 같이 핵심 모듈들이 수정되면, PipelineTabView의 각 버튼(_create_audio, _create_subtitles, _render_video)은 이 모듈들을 순서대로 호출하여 최종 결과물을
  만들어냅니다.



============================================

그러면 이제는 이 파이프라인과 ui에 입력된 데이터와 연동하는 프로그램 통합의 과장이 필요한 것 같애. 
이에 대한 접근 방법을 제시하고, 모든 출력물은 프로젝트 폴더에 정해진 파일명 규칙을 사용하여 출력하도록 수정해야해. 
이 규칙을 정하기 위해 출력내용 규칙을 보여주고 확인을 받고 수행해줘. 
또한 단계적으로 진행하며 통합된 내용을 단계별로 검증하도록 하고, 
디버깅이 용이하도록 진행 절차, 사용 데이터 등을 메시지 창에 출력하도록 해줘

📁 출력 파일명 규칙 제안
/
📋 파일명 규칙 상세
파일 타입	규칙	예시
프로젝트 폴더	{project_name}	kor-chn
Manifest	{project_name}_manifest.json	중국어_기초_회화_일상_인사말_manifest.json
SSML	{project_name}_ssml.txt	중국어_기초_회화_일상_인사말_ssml.txt
오디오	{project_name}_audio.mp3	중국어_기초_회화_일상_인사말_audio.mp3
자막 프레임	{project_name}_scene_{N}_screen{M}_{frame:04d}.png	중국어_기초_회화_일상_인사말_scene_01_screen1_0000.png
최종 비디오	{project_name}_final.mp4	중국어_기초_회화_일상_인사말_final.mp4
프리뷰	{project_name}_preview.mp4	중국어_기초_회화_일상_인사말_preview.mp4
실행 보고서	{project_name}_pipeline_report.json	중국어_기초_회화_일상_인사말_pipeline_report.json
�� 특수 문자 처리 규칙
공백: _ (언더스코어)로 변환
한글: 그대로 사용 (UTF-8 지원)
특수문자: -, _만 허용, 나머지는 _로 변환
길이 제한: 최대 100자
mp3 파일을 ./output/{프로젝트명}/{식별자}/mp3 폴더에 {식별자}_intro.mp3,{식별자}_ending.mp3 파일로 저장한다.
SSML 파일을 ./output/{프로젝트명}/{식별자}/SSML 폴더에 {식별자}_intro.ssml, {식별자}_ending.ssml 파일로 저장한다.
Manifest	./output/{프로젝트명}/{식별자}/manifest 폴더에 {식별자}_intro.json, {식별자}_ending.json
자막 프레임	{project_name}_scene_{N}_screen{M}_{frame:04d}.png	중국어_기초_회화_일상_인사말_scene_01_screen1_0000.png
최종 비디오	{project_name}_final.mp4	중국어_기초_회화_일상_인사말_final.mp4
=======================================
파이프라인 탭 UI와 기능 정의

프로젝트 이름은 데이터 생성의 프로젝트 명을 사용하고, 데이터는 AI 데이터 생성에서 만든 파일을 파싱하여 사용한다. 
           
    8. 자막 이미지 생성 버튼 (추후 기능 정의)
    9. 비디오 렌더링 버튼 (추후 기능 정의)
    

    수정
    
    9. 인트로,엔딩의 Manafest 파일은 문장 단위로 읽어서 만드는 걸로 수정해 줘야 돼
   
   
   
   파일 저장 디렉토리 구조 (최종 확정안)

  모든 생성 파일은 기본적으로 ./output/{프로젝트명}/{식별자}/ 경로 아래에 종류별로
  분류되어 저장됩니다.

   * Manifest 파일:
       * 경로: manifest/
       * 파일명: timeline_manifest.json
       * 전체 경로 예시: ./output/kor-chn/kor-chn/manifest/timeline_manifest.json

   * 오디오 파일 (MP3):
       * 경로: mp3/
       * 파일명 형식: {식별자}_{타입}.mp3 (예: kor-chn_intro.mp3)
       * 전체 경로 예시: ./output/kor-chn/kor-chn/mp3/kor-chn_intro.mp3

   * SSML 파일:
       * 경로: SSML/
       * 파일명 형식: {식별자}_{타입}.ssml (예: kor-chn_intro.ssml)
       * 전체 경로 예시: ./output/kor-chn/kor-chn/SSML/kor-chn_intro.ssml

   * 자막 이미지 파일 (PNG):
       * 경로:
           * 인트로: intro/
           * 엔딩: ending/
           * 회화/대화: dialog/
       * 파일명 형식: {식별자}_{일련번호}.png (예: kor-chn_001.png)
       * 전체 경로 예시: ./output/kor-chn/kor-chn/intro/kor-chn_001.png

   * 최종 비디오 파일 (MP4):
       * 경로: mp4/
       * 파일명 형식: {프로젝트명}_final.mp4
       * 전체 경로 예시: ./output/kor-chn/kor-chn/mp4/kor-chn_final.mp4
