AI 영상 콘텐츠 제작 자동화 프로그램 제작 사양서 (개선안)

1. 시스템 개요

프로그램명: AI Video Caption Generator
목표: AI를 활용하여 언어 학습용 YouTube 영상 콘텐츠의 기획, 스크립팅, 음성/영상 제작 과정을 자동화하고, 시청자 몰입도를 높이는 고품질의 동적 콘텐츠를 대량 생산하는 데스크톱 애플리케이션입니다.

UI 구성

0. 작성 규칙
    - 모든 타이틀과 입력창은  모두 같은 행에 배치 한다. (예: 원어: Dropbox or CSV 파일: 입력박스)
    - 타이틀과 입력창, 드롭박스는 항상 붙여서 표시한다.
    - 입력창, 드롭박스의 크기는 타이틀(텍스트의 갯수 넓이)의 형식으로 표시한다.
    - 한 행에 있는 것은 모두 좌측으로 정렬한다.
    - 메인 윈도우
        - 크기: 1600x900 픽셀, 중앙에 디스플레이
        - 테마: CustomTkinter 모던 테마
        - 탭 구조: 데이터 소스, 화자 선택, 이미지 설정
        - 바탕색 (전체 배경): #2C3E50 (차콜 블루)
            아주 연한 크림색으로, 눈의 피로를 덜어주고 전체적으로 따뜻한 기반을 만듭니다.
            창, 드롭박스 (입력 요소 배경): #34495E (웻 아스팔트)
            바탕색보다 살짝 깊이감이 있는 부드러운 노란색으로, UI 요소들을 명확히 구분해주면서도 조화를 이룹니다.
            버튼 (클릭 요소):
                기본 상태: #3498DB (피터 리버 블루)
                주의를 끄는 친근한 파스텔 톤의 노란색으로, 사용자가 눌러야 할 요소임을 직관적으로 알 수 있게 합니다.
                눌렸을 때 (Pressed): #5DADE2 (밝은 피터 리버 블루)
                기본 상태보다 채도가 약간 더 높은 색상으로 변경하여, 사용자가 버튼을 눌렀다는 것을 명확하게 인지할 수 있도록 시각적인 피드백을 줍니다.
        - 버튼이 눌리면 색을 바꾸는 등 동작 상황을 알 수 있게 하고 실행이 끝나면 원상 복귀한다.
        - 버튼에 쓰이는 라벨은 가독성이 좋은 색깔을 선택해서 쓴다. 버튼 라벨 색상: #FFFFFF (흰색)
    - 프로그램은 유지보수가 편하고 수정이 편할 정도의 크기로 모듈화 된 프로그램으로 만든다.
    
기술 스택
    1. 프로그래밍 언어 : Python 3.6+
    2. 주요 라이브러리
        - customtkinter: 모던한 GUI 인터페이스
        - google-cloud-texttospeech: Google TTS API 클라이언트
        - 기능	            새로운 권장 방식 (안정적)
        오디오 미리듣기	   subprocess + afplay (macOS 내장)
        오디오 편집       subprocess + FFmpeg (필수 설치)

Sheets로 내보내기

        - pygame: 오디오 재생
        - sounddevice: 실시간 음성 녹음
        - Pillow: 이미지 처리

    3. 외부 API
        - Google Cloud Text-to-Speech API: 음성 합성
        - AI 데이터 생성 엔진: 학습 데이터 자동 생성 
            (gemini-2.5-flash, gemini-2.5-pro 모델 선택하도록 구성)

0. 메뉴 구성 방법

    메뉴 구성 방법 : 바탕색(10) 입력창,텍스트 행수(4) Dropbox, 구간(5) 체크박스 와 같은 형식은 
            라벨(크기: 글자 수), 입력창 이나 Dropbox, 체크박스 구분의 형태로 만들어줘
    메뉴버튼을 선택을 하면 선택된 메뉴 버튼은 다른 칼라로 선택 된 것을 표시 해줘야 돼

1. 데이터 생성 메뉴 : 4개의 섹션으로 구성 한다.위에서 아래로 구성한다.
    1.1. 데이터 섹션     
        1행 : '원어'(20), '학습어'(20) Dropbox, '프로젝트명' : 입력창(20), '식별자': 입력창(20)
            원어 : 배우는 사람이 쓰는 언어, 학습어 : 배울 언어
        2행 : '학습 주제'(20) Dropbox, '직접 주제를 입력하세요'(50), '등급'(15) Dropbox,'데이터 개수'(3) Dropbox
        3행: 'AI 서비스'(20) Dropbox, 'AI 데이터 생성' 버튼, '데이터 읽기' 버튼

    1.2. 스크립트 섹션
        - '스크립트 선택:' (30) Dropbox
            회화 스크립트, 타이틀 스크립트, 썸네일 스크립트, 인트로 스크립트,
            엔딩 스크립트, 키워드 스크립트, 배경 스크립트, 대화 스크립트 항목으로 구성되어 있다.
        - 스크립트 창: 스크립트 창에는 '스크립트 선택'에서 선택된 스크립트를 디스플레이 한다. (높이를 2배로 확대)
        - 스크립트는 MD 형식의 텍스트나 CSV 파일로 되어있고 스크립트 창에서 수정할 수 있다.
    

    1.3. 메시지 윈도우
        - 실행중인 프로세스의 진행 상태, 에러메시지 등을 표시하는 창 (높이를 2배로 확대)

    1.4. 콘트롤 버튼 섹션
        - 오디오 생성: 스크립트 전체의 TTS 오디오 파일(.mp3)을 생성합니다.
        - 오디오 듣기: 선택된 스크립트 라인을 TTS로 실시간 재생하여 확인합니다.
        - 썸네일 생성: '썸네일 설정' 탭의 디자인에 따라 썸네일 이미지를 생성합니다.
        - 회화 비디오: 회화 스크립트, 생성된 오디오, '이미지 설정'을 종합하여 회화 영상을 만듭니다.
        - 인트로 비디오: 인트로 스크립트로 각각의 영상을 만듭니다.
        - 엔딩 비디오: 엔딩 스크립트로 각각의 영상을 만듭니다.
        - 대화 비디오: 내레이터와 학습자 간의 대화 형식으로 구성된 별도의 영상을 제작합니다.
        - 정지 버튼: 현재 실행 중인 모든 백그라운드 작업(오디오/비디오 생성, TTS 미리 듣기 등)을 즉시 강제 중단합니다.
        - 종료 버튼: 애플리케이션을 안전하게 종료합니다. 
            변경 후 저장되지 않은 내용이 있을 경우 저장합니다.
        밑에 한줄로 배치한다.

2. 화자 선택 메뉴 : 원어 화자와 학습어 화자를 선택한다.
    2.1. 화면 구성
        - 원어 화자:
            화자 선택 드롭박스(50), 미리듣기 버튼
        - 학습어 화자:
            화자 수 : 학습어 화자 수(6) Dropbox (Default 값 = 4) (수에 따라 학습어 화자의 행이 표시 된다)
                    크기는 세 글자 들어갈 정도의 크기
            학습어 1 선택 드롭박스(50), 미리 듣기 버튼
            학습어 2 선택 드롭박스(50), 미리 듣기 버튼
            학습어 3 선택 드롭박스(50), 미리 듣기 버튼
            학습어 4 선택 드롭박스(50), 미리 듣기 버튼
        각각의 화자와 화자 수는 줄을 맞춰서 정렬 해서 디스플레이 한다.
        - 화자 설정 저장 버튼
            출력 경로: './output/{프로젝트명}/{식별자}/speaker.json로 설정 파일을 저장한다.
            프로그램이 실행할 때는 프로젝트에 맞는 speaker 설정 파일을 읽어온다.

3. 이미지 설정 메뉴

    - 이미지 설정의 UI는 4개의 섹션으로 구성하고 공통 설정, 텍스트 설정, 메시지 창, 콘트롤 섹션으로 구성한다.
 
    3.1. 공통 설정 섹션 (배경 설정 섹션)
        1행: '배경 설정:' 텍스트, '색상','이미지','동영상' (라디오 버튼), 배경값(45) 입력창, '찾아보기' 버튼
            라디오 버튼 선택에 따라 다음과 같이 처리 한다
                색상 : 배경칼라 선택 (칼라) Default = #000000
                이미지 : 배경 이미지 선택 (jpg, png)
                비디오 : 배경 비디오 선택 (mp4)
                찾아 보기 버튼은 이미지일 경우에는 JPG 나 PNG, 동영상일 경우는 MP4 파일을 검색 하게 한다.
            라디오 버튼의 선택에 따라서 입력창에는 해당 데이타를 입력 할 수 있도록 한다
            이제 탭별 배경 설정을 관리하기 위해 다음과 같이 수행:
                각 탭별로 개별 배경 설정 저장
                탭 선택 시 해당 탭의 배경 설정 로드
                배경 설정 변경 시 현재 선택된 탭에만 적용
        2행: '바탕 설정:' 텍스트,  구간(5) 체크박스 Default = False,바탕색(15) 입력창 Default = #000000,
            투명도(10) 입력창 Default = 1.0, 여백(10) Dropbox Default = 2
        3행: '쉐도우 설정:' 텍스트, 두께(6) 입력창 Default = 2, 쉐도우 색상(10) 입력창 Default = #000000,
        4행: '외곽선 설정:' 텍스트, 두께(6) 입력창 Default = 2, 외곽선 색상(10) 입력창 Default = #000000   
        
        2행에서 체크박스 구간은 선택(True)이 될 경우에는 텍스트라인 전체 x,y,xw,xh를 바탕으로 사용하는 형태로 동작 한다.
            False일 경우에는 텍스트 에만 바탕이 생성 된다.
        미리보기 나 비디오 생성에서 이미지를 만들 때는 바탕 설정, 쉐도우 설정,외곽선 설정의 체크박스에 따라 비디오 생성에 반영 한다.

    3.2. 텍스트 설정
        - '회화 설정', '썸네일 설정','인트로 설정', '엔딩 설정', '대화 설정'의 5개 탭으로 구성 되있다.
        - 텍스트 행수(8) Dropbox Default = 4, 화면비율(16) Dropbox Default = 16:9, 
                해상도(16)Dropbox  Default = 1920 X 1080
        - 타이틀은 행, x, y, w, 크기(pt),폰트(pt),색상,굵기,좌우 정렬,상하 정렬로 구성하고 입력창과 Dropbox의 중앙 절렬한다.
        - 각 행의 크기는 다음과 같고 위젯의 데이터는 중앙 정렬한다.
            행(10) 텍스트, x(6) 입력창, y(6)입력창, w(6)입력창, 크기(pt)(6)입력창,
            폰트(pt)(30) Dropbox,색상(10) 입력창,
            굵기(10) Dropbox,좌우 정렬(10) Dropbox,상하 정렬(10) Dropbox 
        - 설정 값 : 
            '폰트(pt)' Dropbox는 시스템에서 제공하는 Noto Sans KR, KoPubWorld돋움체, KoPubWorld바탕체 설정
            '굵기' : 폰트 Dropbox는  weight (Light, Medium, Bold)로 설정
        - 라벨과 입력창, Dropbox는 최소한의 갭을 두고 붙여서 표시한다.
        - 위젯 안의 데이터는 중앙 정렬한다.

        Default 값

        - 회화 설정     텍스트 행수(6) Dropbox Default = 4
            행, x, y, w, 크기(px),폰트(pt),색상,굵기,좌우 정렬,상하 정렬, 바탕설정(10) 체크박스,  쉐도우 설정(10) 체크박스, 외곽선 설정(10) 체크박스 
            순번, 50, 50, 1820, 80, KoPubWorldDotum, #FFFFFF, Bold, Left, Top, False, False,False
            원어, 50, 150, 1820, 100, KoPubWorldDotum, #00FFFF, Bold, Center, Top, False, False,False
            학습어, 50, 450, 1820, 100, Noto Sans Gothic, #FF00FF, Bold, Center, Top, False, False,False
            읽기, 50, 750, 1820, 100, KoPubWorldDotum, #FFFF00, Bold, Center, Top, False, False,False

        - 썸네일 설정     텍스트 행수(6) Dropbox Default = 4
            행, x, y, w, 크기(px),폰트(pt),색상,굵기,좌우 정렬,상하 정렬, 바탕설정(10) 체크박스,  쉐도우 설정(10) 체크박스, 외곽선 설정(10) 체크박스 
            1행, 50, 50, 924, 100, KoPubWorldDotum, #FFFFFF, Bold, Left, Top, False, False,False
            2행, 50, 200, 924, 100, KoPubWorldDotum, #00FFFF, Bold, Left, Top, False, False,False
            3행, 50, 350, 924, 100, KoPubWorldDotum, #FF00FF, Bold, Left, Top, False, False,False
            4행, 50, 500, 924, 100, KoPubWorldDotum, #FFFF00, Bold, Left, Top, False, False,False


        - 인트로 설정     텍스트 행수(6) Dropbox Default = 1
            행, x, y, w, 크기(px),폰트(pt),색상,굵기,좌우 정렬,상하 정렬, 바탕설정(10) 체크박스,  쉐도우 설정(10) 체크박스, 외곽선 설정(10) 체크박스 
            1행, 50, 50, 80, 1820, KoPubWorldDotum, #FFFFFF, Bold, Left, Top, False, False ,False
            

        - 엔딩 설정     텍스트 행수(6) Dropbox Default = 1
            행, x, y, w, 크기(px),폰트(pt),색상,굵기,좌우 정렬,상하 정렬, 바탕설정(10) 체크박스,  쉐도우 설정(10) 체크박스, 외곽선 설정(10) 체크박스 
            1행, 50, 50, 1820, 100, KoPubWorldDotum, #FFFFFF, Bold, Left, Top, False, False,False

        - 대화 설정     텍스트 행수(6) Dropbox Default = 3
            행, x, y, w, 크기(px),폰트(pt),색상,굵기,좌우 정렬,상하 정렬, 바탕설정(10) 체크박스,  쉐도우 설정(10) 체크박스, 외곽선 설정(10) 체크박스 
            원어, 50, 250, 1820, 100, KoPubWorldDotum, #FFFFFF, Bold, Left, Top, False, False,False
            학습어1, 50, 550, 1820, 100, KoPubWorldDotum, #FFFFFF, Bold, Left, Top, False, False,False
            학습어2, 50, 850, 1820, 100, KoPubWorldDotum, #FFFFFF, Bold, Left, Top, False, False,False
   
    3.3 메시지 창 섹션
        현재 UI에 설정된 모든 디자인 값을 JSON 형식 또는 읽기 

    3.4 콘트롤 버튼 섹션
        - '미리보기' 버튼 : (좌측에 배치) 선택된 스크립트의 png 파일을 생성한다.
        - '비디오 생성' 버튼 : (좌측에 배치) 선택된 스크립트의 비디오를 생성한다.
        - '설정 저장' 버튼: (우측에 배치)정의된 모든 데이터를 저장
        - '설정 읽기' 버튼: (우측에 배치)저장된 데이터를 불러와 모든 UI 컨트롤에 값을 복원하여, 일관된 디자인 템플릿을 재사용할 수 있다.

4. 파이프라인 메뉴

    - 파이프라인의 UI는 4개의 섹션으로 구성하고 생성할 스크립트, 편집 창, 출력 창, 콘트롤 섹션으로 구성한다.
 
    4.1. 생성할 스크립트 섹션
        1행 : 생성 할 스크립트:(10) Dropbox, '데이터 저장' 버튼, '데이터 읽기'버튼
        2행 : 편집창
        3행 : 출력창
        4행 : 컨트롤 버튼 섹션
            - 'Manifest 생성' : Manifest 파일 생성
            - '오디오 생성' : 해당 스크립트의 오디오를 생성
            - '자막 이미지 생성' : 해당 스크립트의 자막시퀀스를 생성
            - '비디오 렌더링' : 생성된 Manifest를 활용하여 오디오와 자막을 이용하여 비디오 파일을 생성
            - '최종 생성' : 생성 된 인트로, 회화, 엔딩을 merge하여 하나의 파일을 출력 한다.

프로그램 실행시 전에 실행된 파일이 있으면 그 프로그램을 죽이고 실행한다.




동작 방법

0. 초기화
    - google TTS 연결 (메시지 출력)
        Google TTS에서 지원하는 언어 목록을 동적으로 가져오기
        Google TTS API 인증
    - gemini 2.5 flash 인증 연결 (메시지 출력)

1. 프로젝트 설정
    
    - 언어 페어 : 원어, 학습어 선택 드롭박스에 다음의 지원언어에서 선택하게한다.
        지원 언어
            - 한국어 (ko-KR):
            - 영어: en-US
            - 일본어 (ja-JP)
            - 중국어: cmn-CN
            - 베트남어 (vi-VN)
            - 인도네시아어 (id-ID)
            - 이탈리아어 (it-IT)
            - 스페인어 (es-US)
            - 프랑스어 (fr-FR)
            - 독일어 (de-DE)
    - 프로젝트 명: kor-jan과 같이 [3자리 국가명]-[3자리 국가명] 형식으로 자동 생성됩니다.
    - 식별자: kor-jan과 같이 [3자리 국가명]-[3자리 국가명] 형식으로 자동 생성됩니다.
    - 프로그램이 종료 될 때 실행 프로젝트를 저장했다가 프로그램이 다시 시작할 때 다시 프로젝트명, 식별자와 
      언어 페어로 세팅 한다.
    - 언어 페어가 바뀌거나 '화자 선택' 탭이 선택 되면 선택된 국가의 화자를 선택할 수 있도록 한다.

    - 출력 경로: './output/{프로젝트명}/{식별자}/'에 .json, .csv, .mp3, .mp4, .jpg 
        파일을 {식별자} 이름으로 저장한다.
        
2. 데이타 생성 탭
    - AI 데이터 생성
        - 텍스트 영역학습 주제를 선택 한다.
        - 생성할 스크립트의 톤앤매너, 특정 단어 포함 등 세부 조건을 입력하는 경우에는 추가 요구사항에 입력 한다.
        - 필요시 AI 서비스를 선택한다. gemini-2.5-flash(Default), gemini-2.5-pro
        - 학습 등급을 선택한다.
        - 생성 할 데이터 개수를 입력 한다. Default = 5
        - 'AI 데이터 생성' 버튼을 누른다.
            - 입력 된 데이터를 사용하여 AI Prompt.txt 파일에 위에서 입력된 '주제', '추가 요구사항', '등급', '개수'를 입력하여
            AI 프롬프트를 만들어서 AI에게 데이터 생성을 요청 한다.
            이때 만들어진 prompt 파일을 ./output/{프로젝트명}/{식별자} 폴더에 {식별자}_prompt.txt 파일로 저장한다. (디버깅을 위해)
            - AI가 출력한 JSON 파일을 ./output/{프로젝트명}/{식별자} 폴더에 {식별자}_ai.json으로 저장한다.
            - 출력 된 json 파일을 파싱하여 해당 스크립트 데이터 창에 입력 하고 스크립트 별로 해당 파일명.txt 파일로 
                ./output/{프로젝트명}/{식별자} 폴더에 저장한다.
            
    - '데이터 읽기' 버튼 : 
        ./output/{프로젝트명}/{식별자} 폴더에 {식별자}_ai.json 파일이 있으면 
        {식별자}_ai.json 파일을 파싱하여 해당 스크립트 데이터 창에 입력 한다.
        읽은 후에는 '오디오 생성', '오디오 듣기' 버튼이 활성화 된다.
        회화 스크립트에서 csv 파일을 읽을 때 문장 내에 ','가 있을 때 문장이 나누어지는 경우가 있는데, 
        일을 해결해줘
        
    - '스크립트 선택'을 선택하면 선택된 데이터를 데이터창에 디스플레이하고 오디오 생성, 
        오디오 듣기 버튼이 활성화 되어야한다.
        - 회화 스크립트 창 : 읽어온 CSV 파일을 그리드 형식으로 표시한다.
        - 인트로/ 엔딩 스크립트 창 : 문장 단위로 줄바꿈을 한다.
    
    - 오디오 생성
        1. 회화 오디오 생성
            회화 스크립트 창에서 데이터를 한 행씩 가져와서 오디오를 실시간 생성한다.
            화자 : 원어화자, 학습어 화자 1,2,3,4 
            대화 순번 : 다음과 같이 재생하며 화자간에는 1초의 무음을 넣어준다.
                1. 원어화자 - 원어
                2. 학습어 화자 1 - 학습어
                3. 학습어 화자 2 - 학습어
                4. 학습어 화자 3 - 학습어
                3. 학습어 화자 4 (1 원어, 4 학습어)
            화자간에는 1초의 무음을 넣는다.
            전체 행을 mp3로 만든다.
            SSML `<mark>` 태그를 사용하여 정확한 타이밍이 있는 '오디오 생성'과 
                같은 방법으로 mp3 파일을 만든다.
            이때 만들어진 mp3 파일을 ./output/{프로젝트명}/{식별자}/mp3 폴더에 {식별자}_conversation.mp3 파일로 저장한다.
            이때 만들어진 SSML 파일을 ./output/{프로젝트명}/{식별자}/SSML 폴더에 {식별자}_conversation.ssml 파일로 저장한다.
        2. 인트로/엔딩 오디오 생성
            인트로/엔딩 스크립트 창에서 데이터를 한 문장씩 가져와서 오디오를 실시간 생성한다.
            화자 : 원어화자
            문장 간에는 1초의 무음을 넣는다.
            전체 문장을 mp3로 만든다.
            SSML `<mark>` 태그를 사용하여 정확한 타이밍이 있는 '오디오 생성'과 
                같은 방법으로 mp3 파일을 만든다.
            이때 만들어진 mp3 파일을 ./output/{프로젝트명}/{식별자}/mp3 폴더에 {식별자}_intro.mp3,{식별자}_ending.mp3 파일로 저장한다.
            이때 만들어진 SSML 파일을 ./output/{프로젝트명}/{식별자}/SSML 폴더에 {식별자}_intro.ssml, {식별자}_ending.ssml 파일로 저장한다.


    - 오디오 듣기 conversation
        화자 : 원어화자, 학습어 화자 1,2,3,4 
        대화 순번 : 원어화자, 학습어 화자 1, 학습어 화자 2, 학습어 화자 3, 학습어 화자 4 (1 원어, 4 학습어)순서로 읽기
        읽는 순서 :  각 행별로 다음 순서로 읽고 전체 행을 읽는다.
            원어 화자 : 원어 화자(원어 텍스트), 학습어 화자 1 (학습어 텍스트), 학습어 화자 2 (학습어 텍스트), 
            학습어 화자 3(학습어 텍스트), 학습어 화자 4(학습어 텍스트) 순으로 실시간으로 읽는다.
        각 행별로 원어 화자 및 4명의 학습어 화자(총 5명)에 대해 Google TTS를 호출하는 로직을 구현합니다.
        실시간 듣기로 오디오 재생한다.
        각 화자 오디오 클립 사이에 1초 무음을 포함하여 연결하는 로직을 구현합니다.
        

    - '회화 비디오' 
        각 행별로 2개의 독립적인 텍스트 화면을 생성하는 로직을 구현합니다.
        사전에 다음과 같이 png 자막 파일을 만든다. 
            화면 1: 순번, 원어 텍스트만 화면에 표시한다.
            화면 2: 순번, 원어, 학습어, 읽기를 화면에 표시한다.
        각 화자간, 각 행간에는 무음 1초를 삽입한다.

        SSML `<mark>` 태그를 사용하여 정확한 타이밍이 있는 '오디오 생성'과 같은 방법으로 mp3 파일을 만든다.

        타이밍과 자막 매칭 방법
            화자 : 원어화자, 학습어 화자 1,2,3,4 
            대화 순번 : 다음과 같이 재생하며 화자간, 행간에는 1초의 무음을 넣어준다.
                1. 원어화자 - 원어             화면 1   원어 화자 시작 시간 ~ 종료 시간
                2. 학습어 화자 1 - 학습어       화면 2   학습어 화자 1 시작 시간 ~ 학습어 화자 4 종료시간
                3. 학습어 화자 2 - 학습어       화면 2
                4. 학습어 화자 3 - 학습어       화면 2
                3. 학습어 화자 4 - 학습어       화면 2

        오디오, 자막, 배경을 이용하여 렌더링을 하여 mp4 파일을 만든다.
        
       

    - '인트로 비디오', '엔딩 비디오' 버튼
        문장 단위로 인트로/ 엔딩 스크립트를 읽어 자막을 만들며, 자막의 길이가 길어서 화변 밖으로 나가면 스마트 문장 분리로
        최대 3줄 까지 만든다.
    

        자막은 x, y(좌상위치)을 w(넓이)를 기준으로 줄 수에 따라 위에서 아래로 쓰며, 
            마지막 줄이 항상 x, y값을 마지막 줄의 좌상 값으로 한다.   
        문장은 md 속성으로 문장안에 칼라, 굵기 등 속성을 처리할 수 있게 한다.
        
        SSML `<mark>` 태그를 사용하여 정확한 타이밍이 있는 mp3 파일을 만든다.
        
        오디오, 자막, 배경을 이용하여 렌더링을 하여 mp4 파일을 만든다.
    
    
    '대화 비디오' 버튼
        - 대화문은 내레이터, 화자 1,2 등 정해준 화자로 정해진 위치에 표시하고, 화자 수 만큼 반복해서 읽고
            자막은 화자 1의 시작 시간부터 화자 n의 종료 시간 까지 유지한다.
        - 내레이터가 없으면 화자의 내레이션만 사용한다.

        
    - '정지' 버튼: 현재 실행 중인 모든 백그라운드 작업(오디오/비디오 생성, TTS 미리 듣기 등)을 즉시 강제 중단합니다.

    - '종료' 버튼: 애플리케이션을 안전하게 종료합니다. 변경 후 저장되지 않은 내용이 있을 경우 저장합니다.

3. 화자 선택 탭
    - 오디오 제작에 필요 '원어'(또는 내레이터) '학습어 화자수'를 선택하면 필요한 
        학습어 수(Default 4)만큼을 입력 할 수 있는 행이 만들어진다.
    - '원어', '학습어 화자'의 언어 선택은 기본적으로 '데이터 생성' 탭에서 입력 된 언어 페어('원어', '학습어')를 사용하여 
        자동으로 언어가 선택이 되도록 한다.
    - 자동 선택된 언어의 화자를 Google TTS에서 제공하는 해당 언어의 
        모든 화자가 디스플레이 되도록 한다.
    - '화자 설정 저장'버튼
        - 선택된 모든 화자를 저장하고, '화자 선택' 탭이 눌렀을 경우에는 저장된 데이터가 있으면 
        저장된 데이터를 자동으로 읽어 온다.
        - 화자 설정 JSON 파일을 ./output/{프로젝트명}/{식별자} 폴더에 {식별자}_speaker.json으로 저장한다.
    - '미리듣기' 버튼
        - '미리 듣기'는 '원어', '학습어' 화자 국가의 발음으로 미리듣기를 한다.

4. 이미지 설정 탭
    - 이미지 설정의 UI는 3개의 섹션으로 구성하고 공통 설정, 텍스트 설정, 메시지 창으로 구성한다.
    - 공통 설정 섹션은 
        화면 비율, 해상도
        배경 설정: 색상,이미지,동영상, 입력창
        바탕 설정: 바탕색,투명도,여백
        쉐도우 설정: 두께, 쉐도우 색상 
        외곽선 설정: 두께, 외곽선 색상
    - 텍스트 설정 섹션은 
        회화,썸네일,인트로,엔딩,스크립트의 탭으로 구성 된다.
        각 탭은 텍스트의 위치를 지정 하는 텍스트 설정
        각 탭은 텍스트 행 수를 입력받아 텍스트의 위치를 정하는 행을 표시한다.
        행은 타이틀은 행, x, y, w, 크기(px),폰트(pt),색상,굵기,좌우 정렬,상하 정렬로 구성 된다.
        x = x_pos, y = y_pos, w = width
        회화 탭의 행 이름 : 순번, 원어, 학습어, 읽기
        썸네일 탭, 인트로 탭, 엔딩, 스크립트 탭의 행 이름 : 1행, 2행, 3행, 4행
    - 메시지 창 섹션
        현재 UI에 설정된 모든 디자인 값을 JSON 형식 또는 읽기 

    - '자막 이미지 생성' 버튼

        png 파일을 만든다.
        각 설정 탭에 따라 다음과 같이 동작한다.
        각 텍스트의 속성은 텍스트 설정에 있는 모든 설정 값을 반영하여 텍스트를 생성 한다.
        이미지 설정 탭에서 정리된 설정 값을 반영하여 이미지를 만듭니다.
        파일을 ./output/{프로젝트명}/{식별자} 폴더에 dialog, thumbnail, intro, ending 폴더를 만들어 
            번호를 붙여 {식별자}_001.png의 형식으로 저장한다.

        1. 회화 이미지 생성 : 
            각 행별로 2개의 독립적인 텍스트 화면을 생성하는 로직을 구현합니다.
            화면 1: 순번, 원어 텍스트만 화면에 표시한다.
            화면 2: 순번, 원어, 학습어, 읽기를 화면에 표시한다.
            이미지 생성시 회화 설정에 설정된 데이터를 사용한다.

        2. 썸네일 이미지 생성
            AI 생성 JSON 파일을 읽어 파싱하여 썸네일 문장을 추출하여 사용한다.
            4줄의 텍스트를 읽어 이미지 파일을 만든다. 이떄 읽은 값을 터미널에 출력한다.
            주어진 3 세트를 이미지로 만든다.
            이미지 생성시 썸네일 설정에 설정된 데이터를 사용한다.
            텍스트가 w를 넘는 경우 적당히 폰트사이즈를 줄여 텍스트를 만든다.

        3. 인트로 이미지 생성
            AI 생성 JSON 파일을 읽어 파싱하여 인트로 스크립트를 사용한다.
            문장별로 읽어 문장일 길어 w를 넘으면 스마트 줄바꿈을 하고 상하 정렬이 
                top : x,y를 기준으로 화면 아래로 텍스트를 쓴다.
                bottom : x, y가 마지막 줄의 기준이고 그 위로 줄을 쓴다.
            스크립트 전체 문장을 이미지로 만든다.

        4. 엔딩 이미지 생성    
            인트로 스크립트를 사용한다.md 인라인 스크립트로 텍스트의 속성을 변경한다.
            문장별로 읽어 문장일 길어 w를 넘으면 스마트 줄바꿈을 하고 상하 정렬이 
                top : x,y를 기준으로 화면 아래로 텍스트를 쓴다.
                bottom : x, y가 마지막 줄의 기준이고 그 위로 줄을 쓴다.
            스크립트 전체 문장을 이미지로 만든다.

        5. 대화 설정 : 추후 정의

    - 설정 저장    
        - 정의된 모든 데이터를 저장
    - 설정 읽기
        - 저장된 데이터를 불러와 모든 UI 컨트롤에 값을 복원하여, 일관된 디자인 템플릿을 재사용할 수 있다.





====================
5. 파이프라인	
====================


 최종 제안: Manifest 기반 동적 비디오 자동 생성 파이프라인 (v3 - 최종 구현안)

  이 문서는 timeline_manifest.json을 중심으로, 현재 프로젝트 구조에 맞춰 최종 비디오를 출력하기까지의 모든 과정과 각 핵심 모듈의 전체 구현 코드 예시를 포함한 최종
  실행 계획입니다.

  [1단계] 비디오 구조 설계 (Timeline Manifest)

  모든 제작 과정은 아래 timeline_manifest.json 파일 하나로 제어됩니다. 이 파일을 프로젝트 루트에 생성하거나, UI를 통해 생성/관리하게 됩니다.

  `timeline_manifest.json` (최종 예시)

    1 {
    2   "project_name": "Effective Communication Ep.1",
    3   "resolution": "1920x1080",
    4   "default_background": "assets/bg_main.mp4",
    5   "scenes": [
    6     {
    7       "id": "intro_01",
    8       "type": "intro",
    9       "content": {
   10         "script": "안녕하세요! **효과적인 커뮤니케이션** 시리즈에 오신 것을 환영합니다. 오늘은 *[color=#00FFFF]경청의 중요성[/color]*에 대해 알아봅니다."
   11       }
   12     },
   13     {
   14       "id": "dialogue_01",
   15       "type": "dialogue",
   16       "background": "assets/bg_interview.jpg",
   17       "content": {
   18         "script": [
   19           { "speaker": "A", "text": "어제 보낸 파일 확인하셨나요?" },
   20           { "speaker": "B", "text": "네, 지금 막 확인했습니다. 몇 가지 질문이 있어요." }
   21         ]
   22       }
   23     },
   24     {
   25       "id": "conversation_01",
   26       "type": "conversation",
   27       "content": {
   28         "sequence": 1,
   29         "native_script": "Let's get started.",
   30         "learning_script": "시작해 봅시다.",
   31         "reading_script": "Si-jak-hae bop-si-da."
   32       }
   33     },
   34     {
   35       "id": "ending_01",
   36       "type": "ending",
   37       "content": {
   38         "script": "시청해주셔서 감사합니다. [size=110]**구독과 좋아요**[/size]를 잊지 마세요!"
   39       }
   40     }
   41   ]
   42 }

  ---

  [2단계] 오디오 및 타임스탬프 생성

  위 Manifest를 기반으로, 2단계 파이프라인을 실행하면 다음과 같은 타임스탬프 파일이 생성됩니다.

  `{identifier}_segments.json` (생성 예시)

    1 {
    2   "intro_01_seg_0": { "start": 0.5, "end": 3.2 },
    3   "intro_01_seg_1": { "start": 3.8, "end": 5.1 },
    4   "dialogue_01_A_0": { "start": 5.6, "end": 7.1 },
    5   "dialogue_01_B_0": { "start": 7.5, "end": 9.8 },
    6   "conversation_01_native": { "start": 10.2, "end": 11.0 },
    7   "conversation_01_learning_0": { "start": 12.0, "end": 13.1 },
    8   "conversation_01_learning_1": { "start": 14.1, "end": 15.2 },
    9   "conversation_01_learning_2": { "start": 16.2, "end": 17.3 },
   10   "conversation_01_learning_3": { "start": 18.3, "end": 19.4 },
   11   "ending_01_seg_0": { "start": 20.0, "end": 22.5 }
   12 }

  ---

  [3단계] 핵심 모듈 코드 구현

  아래 내용은 제안서에 따라 수정될 각 핵심 파일의 전체 코드입니다. 이대로 각 파일을 수정하거나 생성하면 됩니다.

  1. `src/ui/ui_utils.py` (신규 생성)
  UI 위젯 생성을 표준화하기 위한 유틸리티 함수입니다.

    1 import customtkinter as ctk
    2 from src import config
    3 import tkinter as tk
    4
    5 def create_labeled_widget(p, label_text, char_width, widget_type="entry", widget_params=None):
    6     frame = ctk.CTkFrame(p, fg_color="transparent")
    7     ctk.CTkLabel(frame, text=f"{label_text}:").pack(side="left", padx=(0, 3), pady=5)
    8     pixel_width = char_width * 9
    9     if pixel_width < 80 and widget_type in ["combo", "dropbox"]:
   10         pixel_width = 80
   11
   12     widget_params = widget_params or {}
   13     if 'fg_color' not in widget_params:
   14         widget_params['fg_color'] = config.COLOR_THEME["widget"]
   15     if 'text_color' not in widget_params:
   16         widget_params['text_color'] = config.COLOR_THEME["text"]
   17
   18     widget = None
   19     if widget_type.lower() in ["combo", "dropbox"]:
   20         widget = ctk.CTkComboBox(frame, width=pixel_width, **widget_params)
   21     elif widget_type.lower() == "checkbox":
   22         widget = ctk.CTkCheckBox(frame, text="", **widget_params)
   23     else:
   24         widget = ctk.CTkEntry(frame, width=pixel_width, **widget_params)
   25
   26     widget.pack(side="left", pady=5)
   27     frame.pack(side="left", padx=(0,10))
   28     return frame, widget

  2. `src/pipeline/subtitle/text_renderer.py` (수정)
  인라인 스타일링, 스마트 줄바꿈, 동적 설정 적용 로직이 포함됩니다.

    1 import os
    2 import re
    3 from typing import Dict, Any, Optional, Tuple, List
    4 from PIL import Image, ImageDraw, ImageFont
    5 import textwrap
    6 from src import config
    7
    8 class TextRenderer:
    9     def __init__(self, settings: Dict[str, Any]):
   10         self.config = self._load_config(settings)
   11         self.fonts = {}
   12
   13     def _load_config(self, settings: Dict[str, Any]) -> Dict[str, Any]:
   14         default_config = {
   15             "fonts": {
   16                 "Noto Sans KR": "~/Library/Fonts/NotoSansKR-Regular.ttf",
   17                 "KoPubWorld돋움체": "~/Library/Fonts/KoPubWorld Dotum Medium.ttf",
   18                 "KoPubWorld바탕체": "~/Library/Fonts/KoPubWorld Batang Medium.ttf"
   19             }
   20         }
   21         self._merge_configs(default_config, settings)
   22         return default_config
   23
   24     def _merge_configs(self, base, user):
   25         for key, value in user.items():
   26             if key in base and isinstance(base[key], dict) and isinstance(value, dict):
   27                 self._merge_configs(base[key], value)
   28             else:
   29                 base[key] = value
   30
   31     def _get_font(self, font_name: str, size: int) -> ImageFont.FreeTypeFont:
   32         if font_name in self.fonts:
   33             return ImageFont.truetype(self.fonts[font_name], size)
   34
   35         font_path = self.config.get("fonts", {}).get(font_name)
   36         if font_path:
   37             font_path = os.path.expanduser(font_path)
   38             if os.path.exists(font_path):
   39                 self.fonts[font_name] = font_path
   40                 return ImageFont.truetype(font_path, size)
   41
   42         print(f"⚠️ 폰트 파일을 찾을 수 없습니다:{font_name}. 기본 폰트를 사용합니다.")
   43         return ImageFont.load_default()
   44
   45     def render_styled_text(self, draw: ImageDraw.ImageDraw, text_segments: List[Dict], x: int, y: int, settings: Dict):
   46         current_x = x
   47         for segment in text_segments:
   48             text = segment.get("text", "")
   49             font_name = segment.get("font", settings.get("폰트(pt)"))
   50             size = int(segment.get("size", settings.get("크기(pt)", 48)))
   51             color = segment.get("color", settings.get("색상", "#FFFFFF"))
   52
   53             font = self._get_font(font_name, size)
   54             draw.text((current_x, y), text, font=font, fill=color)
   55             current_x += draw.textbbox((0,0), text, font=font)[2]
   56
   57     def render_multiline_text(self, lines: List[str], width: int, height: int, line_settings: List[Dict]):
   58         # ... (이전 제안서의 `render_multiline_text` 구현) ...
   59         # 이 부분은 스타일 조각을 처리하도록 `render_styled_text`를 호출하는 로직으로 변경됩니다.
   60         pass # 상세 구현은 생략
   61
   62     # ... conversation, intro, ending 렌더링 메서드들 ...

  3. `src/pipeline/subtitle/generator.py` (수정)
  Manifest와 설정을 받아 TextRenderer를 제어합니다.

    1 import os
    2 from typing import Dict, Any, Optional, List
    3 from .text_renderer import TextRenderer
    4
    5 class SubtitleGenerator:
    6     def __init__(self, settings: Dict[str, Any], identifier: str):
    7         self.text_renderer = TextRenderer(settings)
    8         self.identifier = identifier
    9         self.frames = []
   10         self.output_dir = ""
   11         self.resolution = (1920, 1080)
   12
   13     def generate_from_manifest(self, manifest_data: Dict, output_dir: str):
   14         # ...
   15         # scene type에 따라 _generate_..._frames 메서드 호출
   16         pass
   17
   18     def _generate_intro_frames(self, scene: Dict, start_frame: int, fps: int):
   19         # 1. 스크립트에서 스타일 파싱
   20         # 2. textwrap으로 스마트 줄바꿈
   21         # 3. TextRenderer 호출하여 이미지 생성
   22         # 4. 파일 저장: os.path.join(self.output_dir, f"{self.identifier}_{start_frame:03d}.png")
   23         pass
   24
   25     # ... conversation, ending, dialogue 프레임 생성 메서드들 ...

  4. `src/pipeline/ffmpeg/renderer.py` (신규 또는 수정)
  모든 에셋을 최종 비디오로 결합합니다.

    1 import ffmpeg
    2
    3 class FFmpegRenderer:
    4     def render_video(self, manifest: Dict, segments: Dict, master_audio_path: str, image_sequence_paths: Dict):
    5         bg_path = manifest.get("default_background")
    6         resolution = manifest.get("resolution", "1920x1080").split('x')
    7         width, height = int(resolution[0]), int(resolution[1])
    8
    9         video_stream = ffmpeg.input(bg_path, loop=1, t=segments['total_duration'])
   10         audio_stream = ffmpeg.input(master_audio_path)
   11
   12         for scene_id, scene_images in image_sequence_paths.items():
   13             for img_info in scene_images:
   14                 img_path = img_info['path']
   15                 start = img_info['start']
   16                 end = img_info['end']
   17                 subtitle_stream = ffmpeg.input(img_path)
   18                 video_stream = video_stream.overlay(subtitle_stream, enable=f'between(t,{start},{end})')
   19
   20         output_path = f"./output/{manifest['project_name']}_final.mp4"
   21         (
   22             ffmpeg
   23             .output(video_stream, audio_stream, output_path, vcodec='libx264', acodec='aac', strict='experimental', shortest=None)
   24             .run(overwrite_output=True)
   25         )
   26         print(f"✅ 최종 비디오 생성 완료: {output_path}")

  ---

  [4단계] 실행 및 검증

  위와 같이 핵심 모듈들이 수정되면, PipelineTabView의 각 버튼(_create_audio, _create_subtitles, _render_video)은 이 모듈들을 순서대로 호출하여 최종 결과물을
  만들어냅니다.



============================================


그러면 이제는 이 파이프라인과 ui에 입력된 데이터와 연동하는 프로그램 통합의 과장이 필요한 것 같애. 
이에 대한 접근 방법을 제시하고, 모든 출력물은 프로젝트 폴더에 정해진 파일명 규칙을 사용하여 출력하도록 수정해야해. 
이 규칙을 정하기 위해 출력내용 규칙을 보여주고 확인을 받고 수행해줘. 
또한 단계적으로 진행하며 통합된 내용을 단계별로 검증하도록 하고, 
디버깅이 용이하도록 진행 절차, 사용 데이터 등을 메시지 창에 출력하도록 해줘

=======================================
파이프라인 탭 UI와 기능 정의

프로젝트 이름은 데이터 생성의 프로젝트 명을 사용하고, 데이터는 AI 데이터 생성에서 만든 파일을 파싱하여 사용한다. 
           
    8. 자막 이미지 생성 버튼 (추후 기능 정의)
    9. 비디오 렌더링 버튼 (추후 기능 정의)
    

    수정
    
    9. 인트로,엔딩의 Manafest 파일은 문장 단위로 읽어서 만드는 걸로 수정해 줘야 돼
   
   
   
   파일 저장 디렉토리 구조 (최종 확정안)

  모든 생성 파일은 기본적으로 ./output/{프로젝트명}/{식별자}/ 경로 아래에 종류별로
  분류되어 저장됩니다.

   * Manifest 파일:
       * 경로: manifest/
       * 파일명: {식별자}_conversation.json  {식별자}_intro, {식별자}_ending
       * 전체 경로 예시: ./output/kor-chn/kor-chn/manifest/{식별자}_conversation.json 

   * 오디오 파일 (MP3):
       * 경로: mp3/
       * 파일명 형식: {식별자}_{타입}.mp3 (예: kor-chn_intro.mp3)
       * 전체 경로 예시: ./output/kor-chn/kor-chn/mp3/kor-chn_intro.mp3

   * SSML 파일:
       * 경로: SSML/
       * 파일명 형식: {식별자}_{타입}.ssml (예: kor-chn_intro.ssml)
       * 전체 경로 예시: ./output/kor-chn/kor-chn/SSML/kor-chn_intro.ssml

   * 자막 이미지 파일 (PNG):
       * 경로:
           * 인트로: intro/
           * 엔딩: ending/
           * 회화/대화: dialog/
       * 파일명 형식: {식별자}_{일련번호}.png (예: kor-chn_001.png)
       * 전체 경로 예시: ./output/kor-chn/kor-chn/intro/kor-chn_001.png

   * 최종 비디오 파일 (MP4):
       * 경로: mp4/
       * 파일명 형식: {프로젝트명}_final.mp4
       * 전체 경로 예시: ./output/kor-chn/kor-chn/mp4/kor-chn_final.mp4


수정(최종)

파이프라인 탭 UI와 기능 정의

    - 파이프라인의 UI는 4개의 섹션으로 구성하고 생성할 스크립트, 편집 창, 출력 창, 콘트롤 섹션으로 구성한다.
 
        1섹션 : 생성 할 스크립트:(10) Dropbox, '데이터 저장' 버튼, '데이터 읽기'버튼
        2섹션 : 편집창
        3섹션 : 출력창
        4섹션 : 컨트롤 버튼 섹션
            - 'Manifest 생성' : Manifest 파일 생성
            - '오디오 생성' : 해당 스크립트의 오디오를 생성
            - '자막 이미지 생성' : 해당 스크립트의 자막시퀀스를 생성
            - '비디오 렌더링' : 생성된 Manifest를 활용하여 오디오와 자막을 이용하여 비디오 파일을 생성
            - '최종 생성' : 생성 된 인트로, 회화, 엔딩을 merge하여 하나의 파일을 출력 한다.

0. 공통사항

모든 비디오 제작은 회화,인트로,엔딩,대화 별로 생성 스크립트 에서 선택된 것으로 만든다.
모든 생성 파일은 기본적으로 ./output/{프로젝트명}/{식별자}/ 경로 아래에 종류별로 분류되어 저장됩니다.

- 또한 단계적으로 진행하며 통합된 내용을 단계별로 검증하도록 하고, 
    디버깅이 용이하도록 진행 절차, 사용 데이터 등을 메시지 창에 출력하도록 해줘
- 비디오 제작을 인트로,회화,엔딩 등을 따로따로 비디오 렌더링을 해서 확인할 수 있도록 하고
- '최종 생성'에서는 생성 된 인트로, 회화, 엔딩 비디오 파일을 merge 하는 형태로 작업을 한다.
==============================



1. UI 구성


    a. 생성 스크립트 : Dropbox

        - 회화,인트로,엔딩,대화를 선택할 수 있다. 
        - 파일명으로 사용할 때는 {식별자}_{스크립트} 형태에 해당 파일 속성자를 사용한다.
            (예) kor-chn_intro.mp3 등
        - 선택된 내용에 따라서 매니페스트 생성, 오디오 생성,자막 이미지 생성,비디오 렌더링,최종 생성의 컨트롤 박스 가동하도록 한다.
        
        - '데이터 저장' 버튼 : 편집 창에서 편집 된 내용을 파일 명을 사용하여 저장 한다. 
            (예) kor-chn_conversation.csv, kor-chn_intro.txt, kor-chn_ending.txt 등
        - '데이터 읽기'버튼 : 저장된 파일((예) kor-chn_intro.txt)을 읽어서 데이터 윈도에 디스플레이 한다.
            - 회화 스크립트 창 : 읽어온 CSV 파일을 그리드 형식으로 표시한다.
            - 인트로/ 엔딩 스크립트 창 : 문장 단위로 줄바꿈을 하여 디스플레이 한다.

    b. 데이터 윈도우 : 편집 윈도우
        선택된 생성 스크립트 창의 데이터를 디스플레이 하고 편집 할 수 있도록 한다. (복사,부치기,취소,삭제 등)
        - AI가 출력한 JSON 파일을 ./output/{프로젝트명}/{식별자} 폴더에 {식별자}_ai.json으로 저장된 데이터를 사용한다.
        - 저장 된 json 파일을 파싱하여 해당 스크립트 데이터 창에 입력 하고 스크립트 별로 해당 {식별자}_{스크립트}.txt 파일로 
                ./output/{프로젝트명}/{식별자} 폴더에 저장한다.
                (예) kor-chn_conversation.csv, kor-chn_intro.txt, kor-chn_ending.txt 등
    
    c. 출력 윈도우 : 출력,편집 윈도우
        - 컨트롤 박스의 동작 상태를 모니터 할 수 있도록 로그를 디스플레이 한다.
        - 디버깅을 위해서 디스플레이 된 데이터를 복사 붙이기 할 수 있도록 한다.
        - 컨트롤 박스 동작에 사용된 이미지 설정,화자,데이터 등을 단계적으로 디스플레이 한다.
        - 생성 된 출력 파일을 디렉토리와 파일 네임으로 표시 하여 확인할 수 있도록 한다. 
        - 이 때 해당 파일을 선택하고  opt + shift 키를 누르면 선택된 파일을 프리뷰 할 수 있도록 한다.

    c. 'Manafest 생성' 버튼
        - 선택된 생성 스크립트 편집 창의 데이터를 읽어 manifest 파일을 만든다.
            * 경로: manifest/
            * 파일명: {식별자}_conversation.json  {식별자}_intro, {식별자}_ending
            * 전체 경로 예시: ./output/kor-chn/kor-chn/manifest/{식별자}_conversation.json 
        - 생성 된 Manafest 파일을 출력 창에 디스플레이 한다.

    d. '오디오 생성' 버튼
        1. 회화 오디오 생성
            회화 스크립트 창에서 데이터를 한 행씩 가져와서 오디오를 실시간 생성한다.
            화자 : 원어화자, 학습어 화자 1,2,3,4 
            대화 순번 : 다음과 같이 재생하며 화자간에는 1초의 무음을 넣어준다.
                1. 원어화자 - 원어
                2. 학습어 화자 1 - 학습어
                3. 학습어 화자 2 - 학습어
                4. 학습어 화자 3 - 학습어
                3. 학습어 화자 4 (1 원어, 4 학습어)
            화자간에는 1초의 무음을 넣는다.
            전체 행을 mp3로 만든다.
            SSML `<mark>` 태그를 사용하여 정확한 타이밍이 있는 '오디오 생성'과 
                같은 방법으로 mp3 파일을 만든다.
            이때 만들어진 mp3 파일을 ./output/{프로젝트명}/{식별자}/mp3 폴더에 {식별자}_conversation.mp3 파일로 저장한다.
            이때 만들어진 SSML 파일을 ./output/{프로젝트명}/{식별자}/SSML 폴더에 {식별자}_conversation.ssml 파일로 저장한다.
        2. 인트로/엔딩 오디오 생성
            인트로/엔딩 스크립트 창에서 데이터를 한 문장씩 가져와서 오디오를 실시간 생성한다.
            화자 : 원어화자
            문장 간에는 1초의 무음을 넣는다.
            전체 문장을 mp3로 만든다.
            SSML `<mark>` 태그를 사용하여 정확한 타이밍이 있는 '오디오 생성'과 
                같은 방법으로 mp3 파일을 만든다.
            이때 만들어진 mp3 파일을 ./output/{프로젝트명}/{식별자}/mp3 폴더에 {식별자}_intro.mp3,{식별자}_ending.mp3 파일로 저장한다.
            이때 만들어진 SSML 파일을 ./output/{프로젝트명}/{식별자}/SSML 폴더에 {식별자}_intro.ssml, {식별자}_ending.ssml 파일로 저장한다.

    e. '자막 이미지 생성' 버튼
        png 파일을 만든다.
            각 생성할 스크립트에 따라 다음과 같이 동작한다.
            각 텍스트의 속성은 '이미지 설정'에 있는 모든 설정 값을 반영하여 텍스트를 생성 한다.
            파일을 ./output/{프로젝트명}/{식별자} 폴더에 dialog, thumbnail, intro, ending 폴더를 만들어 
                번호를 붙여 {식별자}_001.png의 형식으로 저장한다.

            1. 회화 이미지 생성 : 
                각 행별로 2개의 독립적인 텍스트 화면을 생성하는 로직을 구현합니다.
                화면 1: 순번, 원어 텍스트만 화면에 표시한다.
                화면 2: 순번, 원어, 학습어, 읽기를 화면에 표시한다.
                회화 이미지 생성시 데이터 창에 설정된 데이터를 한 행씩 읽어서 사용한다.

            2. 썸네일 이미지 생성
                AI 생성 JSON 파일을 읽어 파싱하여 썸네일 문장을 추출하여 사용한다.
                4줄의 텍스트를 읽어 이미지 파일을 만든다. 이떄 읽은 값을 터미널에 출력한다.
                주어진 3 세트를 이미지로 만든다.
                이미지 생성시 썸네일 설정에 설정된 데이터를 사용한다.
                텍스트가 w를 넘는 경우 적당히 폰트사이즈를 줄여 텍스트를 만든다.

            3. 인트로 이미지 생성
                데이터 창의 인트로 스크립트를 사용한다. md 인라인 스크립트로 텍스트의 속성을 변경한다.
                문장별로 읽어 문장일 길어 w를 넘으면 스마트 줄바꿈을 하고 상하 정렬이 
                    top : x,y를 기준으로 화면 아래로 텍스트를 쓴다.
                    bottom : x, y가 마지막 줄의 기준이고 그 위로 줄을 쓴다.
                스크립트 전체를 문장별로 이미지로 만든다.

            4. 엔딩 이미지 생성    
                데이터 창의 인트로 스크립트를 사용한다. md 인라인 스크립트로 텍스트의 속성을 변경한다.
                문장별로 읽어 문장일 길어 w를 넘으면 스마트 줄바꿈을 하고 상하 정렬이 
                    top : x,y를 기준으로 화면 아래로 텍스트를 쓴다.
                    bottom : x, y가 마지막 줄의 기준이고 그 위로 줄을 쓴다.
                스크립트 전체를 문장별로 이미지로 만든다.


            5. 대화 설정 : 추후 정의

    f. '비디오 렌더링' 버튼
        
        - 생성할 스크립트에서 선택된 비디오를 만든다.
        - 파일명 : {식별자}_{타입}.mp4 (예: kor-chn_intro.mp4)
        - 해당 Manifest파일, 오디오 파일, 자막 이미지 시퀀스, SSML 등을 사용하여 mp4파일을 만든다
        
    g. '최종 병합' 버튼
        - 생성 된 {식별자}_{타입}.mp4 (예 : kor-chn_conversation.mp4, kor-chn_intro.mp4,
            kor-chn_ending.mp4 등을 merge하여 최종 비디오 파일을 만든다.
        - 생성된 인트로, 대화, 엔딩 비디오를 합해서 하나의 프로그램 출력을 생성 한다.
    
    h. '자동 생성' 버튼
        - 수동으로 만들던 프로세스 전체를 자동으로 해서 최종 비디오를 만든다.
        - 각각의 스크립트에 대해서 매니페스트 생성,오디오 생성,자막이 이미지 생성,타임라인 생성,비디오 렌더링,
            최종 병합의 모든 과정을 실행 해서 하나의 프로그램 출력을 생성 한다.

  
  
  
  파일 저장 디렉토리 구조 (최종 확정안)

  모든 생성 파일은 기본적으로 ./output/{프로젝트명}/{식별자}/ 경로 아래에 종류별로
  분류되어 저장됩니다.

   * Manifest 파일:
       * 경로: manifest/
       * 파일명: {식별자}_conversation.json  {식별자}_intro, {식별자}_ending
       * 전체 경로 예시: ./output/kor-chn/kor-chn/manifest/{식별자}_conversation.json 

   * 오디오 파일 (MP3):
       * 경로: mp3/
       * 파일명 형식: {식별자}_{타입}.mp3 (예: kor-chn_intro.mp3)
       * 전체 경로 예시: ./output/kor-chn/kor-chn/mp3/kor-chn_intro.mp3

   * SSML 파일:
       * 경로: SSML/
       * 파일명 형식: {식별자}_{타입}.ssml (예: kor-chn_intro.ssml)
       * 전체 경로 예시: ./output/kor-chn/kor-chn/SSML/kor-chn_intro.ssml

   * 자막 이미지 파일 (PNG):
       * 경로:
           * 인트로: intro/
           * 엔딩: ending/
           * 회화/대화: dialog/
       * 파일명 형식: {식별자}_{일련번호}.png (예: kor-chn_001.png)
       * 전체 경로 예시: ./output/kor-chn/kor-chn/intro/kor-chn_001.png

   * 비디오 렌더링, 최종 비디오 파일 (MP4):
       * 경로: mp4/
       * 파일명 형식: {프로젝트명}_final.mp4, kor-chn_conversation.mp4, kor-chn_intro.mp4,kor-chn_ending.mp4 등
       * 전체 경로 예시: ./output/kor-chn/kor-chn/mp4/kor-chn_final.mp4


- 생성 스크립트를 선택 한 것에 따라서 해당 비디오를 만드는 프로세스를 생성 한다.




파일 저장: 모든 장면 처리가 끝나면, 완성된 JSON 객체를 {식별자}_{타입}.json 파일명으로 지정된 경로에 저장한다.네, 제안해주신 내용은 **아주 훌륭하고 체계적입니다.** 전체적인 흐름과 필요한 데이터가 거의 완벽하게 정리되어 있습니다.

제가 몇 가지 사소한 부분을 수정하고, 더 안정적인 실행을 위해 **예외 처리 부분을 보강**하여 최종 명세서를 완성했습니다. 아래 수정된 내용을 확인하시고 이대로 진행하시면 됩니다.

-----------------------------------------------------------
'타임라인 생성' 버튼 

    '자막 이미지 생성' 버튼 다음에 '타임라인 생성' 버튼을 만든다.

1. 기능 목표
    이전 단계에서 생성된 매니페스트, 오디오 타이밍 정보, 이미지 시퀀스 파일들을 종합하여, 최종 비디오 렌더링에 필요한 모든 정보를 담은 타임라인 JSON 파일을 생성한다.

2. 입력 (Inputs)
    이 기능은 다음 파일들을 입력으로 사용한다.

    * 매니페스트 파일 (`manifest.json`):
        * 비디오를 구성하는 전체 장면(Scene)의 순서와 종류(인트로, 회화, 엔딩)에 대한 정보를 담고 있다.
        * 경로 예시: `output/{프로젝트명}/{식별자}/manifest/{식별자}_{타입}.json`

    * 오디오 타이밍 파일 (`timing.json`):
        * '오디오 생성' 버튼이 생성한 파일로, SSML의 각 `<mark>` 태그에 해당하는 정확한 시작/종료 시간(초) 정보를 담고 있다.
        * 경로 예시: `output/{프로젝트명}/{식별자}/timing/{식별자}_{타입}_timing.json`

    * 자막 이미지 파일들 (Image Sequence):
        * `PNGRenderer`가 생성한 모든 PNG 이미지 파일들.
        * 경로 예시: `output/{프로젝트명}/{식별자}/{타입}/` 디렉토리 내의 모든 `.png` 파일

    * 최종 오디오 파일 (Final Audio):
        * 모든 음성 세그먼트가 합쳐진 최종 MP3 파일.
        * 경로 예시: `output/{프로젝트명}/{식별자}/mp3/{식별자}_{타입}.mp3`

3. 출력 (Output)
* 파일명: `{식별자}_{타입}.json`
* 저장 경로: `output/{프로젝트명}/{식별자}/timeline` 
    * 참고: 일반적으로 프로그래밍에서는 하이픈(`-`)이나 언더스코어(`_`) 없이 `timeline`으로 사용하는 경우가 많아 수정했습니다.*
* 설명: 비디오 렌더링에 필요한 모든 정보를 담은 JSON 파일.

4. 핵심 처리 로직 (Step-by-Step)

1.  입력 파일 로드: 필요한 모든 입력 파일들(manifest, timing)의 내용을 읽어온다.
2.  타임라인 초기화: 최종 JSON의 기본 구조를 생성한다. (예: `resolution`, `final_audio_path`, `timeline: []`)
3.  장면(Scene) 순회: `manifest.json`에 있는 `scenes` 리스트를 순서대로 하나씩 처리한다.
4.  데이터 매칭: 각 장면에 대해 다음을 수행한다.
    * `timing.json`에서 해당 장면의 ID와 일치하는 시간 정보(시작/종료 시간)를 찾는다.
    * 규칙에 따라 해당 장면에 사용할 이미지 파일의 예상 경로(예: `.../intro/kor-chn_intro_001.png`)를 생성한다.
    * 생성한 이미지 경로에 실제 파일이 존재하는지 확인한다.
5.  타임라인 객체 생성: 위에서 매칭한 정보를 바탕으로, 타임라인에 추가할 JSON 객체를 만든다. 이 객체에는 `scene_id`, `start_time`, `end_time`, `duration`, `image_path` 등이 포함된다.
6.  타임라인에 추가: 생성된 객체를 `timeline` 리스트에 추가한다.
7.  파일 저장:  모든 장면 처리가 끝나면, 완성된 타임라인 객체를 지정된 경로와 파일명으로 저장한다.

5. 예외 처리 (Error Handling) 
    안정적인 기능을 위해 다음 예외 상황들을 처리해야 한다.

    * 필수 파일 누락: `manifest.json` 또는 `timing.json` 파일이 없을 경우, "필수 파일이 없습니다." 라는 명확한 오류 메시지를 보여주고 작업을 중단한다.
    * 데이터 불일치: `manifest.json`에 정의된 장면이 `timing.json`에 없을 경우, 해당 장면은 건너뛰고 "타이밍 정보를 찾을 수 없어 [장면 ID]를 건너뜁니다." 와 같은 경고 로그를 남긴다.
    * 이미지 파일 누락: 타임라인에 추가할 이미지 파일이 실제 경로에 존재하지 않을 경우, 해당 장면을 건너뛰고 "이미지 파일이 없어 [장면 ID]를 건너뜁니다." 와 같은 경고 로그를 남긴다.




네, 제작 사양서를 바탕으로 파이프라인 프로세스를 정리하겠습니다.

## **파이프라인 프로세스 정의서**

### **1. 전체 프로세스 구조**
```
데이터 입력 → 매니페스트 생성 → 오디오 생성 → 자막 이미지 생성 → 타임라인 생성 → 비디오 렌더링 → 최종 병합
```

### **2. 각 단계별 상세 정의**

#### **A. 데이터 입력 단계**
- **입력**: UI에서 선택된 스크립트 데이터 (회화/인트로/엔딩)
- **출력**: 구조화된 스크립트 데이터
- **요구사항**: 
  - 프로젝트명, 식별자, 스크립트 타입 확인
  - 각 스크립트별 장면(Scene) 데이터 추출

#### **B. 매니페스트 생성 단계**
- **입력**: 스크립트 데이터
- **출력**: `{식별자}_{타입}.json` (예: kor-chn_conversation.json)
- **저장위치**: `output/{프로젝트명}/{식별자}/manifest/`
- **내용**: 
  - 프로젝트 메타데이터
  - 각 장면별 텍스트, 화자, 타이밍 정보
  - 해상도, 비율 등 설정 정보

#### **C. 오디오 생성 단계**
- **입력**: 매니페스트 파일
- **출력**: `{식별자}_{타입}.mp3` (예: kor-chn_conversation.mp3)
- **저장위치**: `output/{프로젝트명}/{식별자}/mp3/`
- **처리과정**:
  - SSML 생성 (화자별 음성 설정)
  - Google Cloud TTS로 음성 합성
  - 각 장면별 오디오 세그먼트 생성
  - 최종 오디오 파일 병합
  - 정확한 타이밍 정보 생성 (`{식별자}_{타입}_timing.json`)

#### **D. 자막 이미지 생성 단계**
- **입력**: 매니페스트 파일, 텍스트 설정
- **출력**: PNG 이미지 시퀀스
- **저장위치**: `output/{프로젝트명}/{식별자}/conversation/` 또는 `intro/`, `ending/`
- **파일명 규칙**:
  - 회화: `{식별자}_{순번:03d}_screen1.png`, `{식별자}_{순번:03d}_screen2.png`
  - 인트로/엔딩: `{식별자}_{순번:03d}.png`
- **처리과정**:
  - 각 장면별로 텍스트 렌더링
  - 배경, 폰트, 색상, 정렬 등 설정 적용
  - 회화의 경우 Screen1(순번+원어), Screen2(순번+원어+학습어+읽기) 생성

#### **E. 타임라인 생성 단계**
- **입력**: 매니페스트, 타이밍 정보, 이미지 파일들
- **출력**: `{식별자}_{타입}.json` (예: kor-chn_conversation.json)
- **저장위치**: `output/{프로젝트명}/{식별자}/timeline/`
- **내용**:
  - 해상도 정보
  - 최종 오디오 파일 경로
  - 각 이미지별 시작/종료 시간
  - 총 재생 시간 (오디오 길이와 동일)

#### **F. 비디오 렌더링 단계**
- **입력**: 타임라인 파일, 이미지 파일들, 오디오 파일
- **출력**: `{식별자}_{타입}.mp4` (예: kor-chn_conversation.mp4)
- **저장위치**: `output/{프로젝트명}/{식별자}/mp4/`
- **처리과정**:
  - FFmpeg를 사용한 이미지-오디오 동기화
  - 타임라인에 따른 정확한 타이밍 적용
  - H.264 코덱으로 MP4 생성

#### **G. 최종 병합 단계**
- **입력**: 인트로, 회화, 엔딩 비디오 파일들
- **출력**: `{프로젝트명}.mp4`
- **저장위치**: `output/{프로젝트명}/mp4`
- **처리과정**:
  - 인트로 + 회화 + 엔딩 순서로 비디오 병합
  - 부드러운 전환 효과 적용
  - 최종 프로그램 완성

### **3. UI 버튼별 기능 정의**

#### **개별 실행 버튼들**
1. **"1. Manifest 생성"** → A→B 단계만 실행
2. **"2. 오디오 생성"** → B→C 단계만 실행 (매니페스트 필요)
3. **"3. 자막 이미지 생성"** → B→D 단계만 실행 (매니페스트 필요)
4. **"4. 타임라인 생성"** → B,C,D→E 단계만 실행 (매니페스트, 오디오, 이미지 필요)
5. **"5. 비디오 렌더링"** → E→F 단계만 실행 (타임라인 필요)
6. **"6. 최종 병합"** → F→G 단계만 실행 (모든 비디오 필요)

#### **자동 실행 버튼**
7. **"자동 생성"** → A→G 전체 프로세스 자동 실행

### **4. 파일 구조**
```
output/
├── {프로젝트명}/
│   ├── {식별자}/
│   │   ├── manifest/
│   │   │   └── {식별자}_{타입}.json
│   │   ├── mp3/
│   │   │   ├── {식별자}_{타입}.mp3
│   │   │   └── {식별자}_{타입}_timing.json
│   │   ├── conversation/ (또는 intro/, ending/)
│   │   │   └── {식별자}_{순번:03d}_screen1.png
│   │   ├── timeline/
│   │   │   └── {식별자}_{타입}.json
│   │   └── mp4/
│   │       ├── {식별자}_{타입}.mp4
│           └── {프로젝트명}_final.mp4
```

### **5. 에러 처리 및 의존성**
- 각 단계는 이전 단계의 결과물이 존재해야 실행 가능
- 파일 존재 여부 확인 후 진행
- 실패 시 명확한 에러 메시지 제공
- 부분 실행 시 이어서 실행 가능하도록 설계

### **6. 성능 최적화**
- 병렬 처리 가능한 단계는 동시 실행
- 중간 결과물 캐싱
- 진행 상황 실시간 표시
- 메모리 효율적인 파일 처리



파이프라인 프로세스 정의서

1. 전체 프로세스 구조
    데이터 입력 → 매니페스트 생성 → 오디오 생성 → 자막 이미지 생성 → 타임라인 생성 
    → 비디오 렌더링 → 최종 병합 -> 자동 생성

2. 각 단계별 상세 정의

    A. 데이터 입력 단계
        - 입력: UI에서 선택된 스크립트 데이터 (회화/인트로/엔딩)
        - 출력: 구조화된 스크립트 데이터
        - 요구사항: 
        - 프로젝트명, 식별자, 스크립트 타입 확인
        - 각 스크립트별 장면(Scene) 데이터 추출

    B. 매니페스트 생성 단계
        - 입력: 스크립트 데이터
        - 출력: {식별자}_{타입}.json (예: kor-chn_conversation.json)
        - 저장위치: output/{프로젝트명}/{식별자}/manifest/
        - 내용: 
        - 프로젝트 메타데이터
        - 각 장면별 텍스트, 화자, 타이밍 정보
        - 해상도, 비율 등 설정 정보

    C. 오디오 생성 단계
        - 입력: 매니페스트 파일
        - 출력: {식별자}_{타입}.mp3 (예: kor-chn_conversation.mp3)
        - 저장위치: output/{프로젝트명}/{식별자}/mp3/
        - 처리과정:
        - SSML 생성 (화자별 음성 설정)
        - Google Cloud TTS로 음성 합성
        - 각 장면별 오디오 세그먼트 생성
        - 최종 오디오 파일 병합
        - 정확한 타이밍 정보 생성
        - 타이밍 정보 저장위치: output/{프로젝트명}/{식별자}/timing/
        - 타이밍 파일명: {식별자}_{타입}.json

    D. 자막 이미지 생성 단계
        - 입력: 매니페스트 파일, 텍스트 설정
        - 출력: PNG 이미지 파일들
        - 저장위치: output/{프로젝트명}/{식별자}/subtitles/
        - 처리과정:
        - 회화: 각 장면별로 2개 이미지 생성 (Screen1: 순번+원어, Screen2: 순번+원어+학습어+읽기)
        - 인트로/엔딩: 문장별로 이미지 생성
        - 배경, 폰트, 색상, 정렬 등 설정 적용

    E. 타임라인 생성 단계
        - 입력: 매니페스트, 타이밍 정보, 이미지 파일들
        - 출력: {식별자}_{타입}.json (예: kor-chn_conversation.json)
        - 저장위치: output/{프로젝트명}/{식별자}/timeline/
        - 내용:
        - 해상도, 최종 오디오 경로, 총 재생시간
        - 각 장면별 시작/종료 시간, 이미지 경로
        - 비디오 렌더링을 위한 동기화 정보
        - 타이밍과 자막 매칭 방법
            화자 : 원어화자, 학습어 화자 1,2,3,4 
            대화 순번 : 다음과 같이 재생하며 화자간, 행간에는 1초의 무음을 넣어준다.
                1. 원어화자 - 원어             화면 1   원어 화자 시작 시간 ~ 종료 시간
                2. 학습어 화자 1 - 학습어       화면 2   학습어 화자 1 시작 시간 ~ 학습어 화자 4 종료시간
                3. 학습어 화자 2 - 학습어       화면 2
                4. 학습어 화자 3 - 학습어       화면 2
                3. 학습어 화자 4 - 학습어       화면 2

        오디오, 자막, 배경을 이용하여 렌더링을 하여 mp4 파일을 만든다.

    F. 비디오 렌더링 단계
        - 입력: 타임라인 파일, 오디오 파일, 이미지 파일들
        - 출력: {프로젝트명}_{타입}.mp4 (예: kor-chn_conversation.mp4)
        - 저장위치: output/{프로젝트명}/{식별자}/mp4/
        - 처리과정:
        - FFmpeg을 사용한 이미지-오디오 동기화
        - 각 이미지를 지정된 시간 동안 표시
        - 최종 MP4 비디오 생성

    G. 최종 병합 단계
        - 입력: 인트로, 회화, 엔딩 비디오 파일들
        - 출력: {프로젝트명}_final.mp4
        - 저장위치: output/{프로젝트명}/{식별자}/mp4/
        - 처리과정:
        - FFmpeg을 사용한 비디오 파일들 순차 병합
        - 최종 완성된 교육용 비디오 생성

    H. 자동 생성 버튼 기능
        - 기능: 위의 A~G 단계를 순차적으로 자동 실행
        - 실행 순서:
            1. 매니페스트 생성 → 2. 오디오 생성 → 3. 자막 이미지 생성 → 4. 타임라인 생성 → 
            5. 비디오 렌더링 → 6. 최종 병합
        - 오류 처리: 각 단계별 성공/실패 확인 및 오류 메시지 표시
        - 진행 상황: 실시간 로그 출력 및 UI 상태 업데이트
        - 결과물: 완성된 교육용 비디오 파일 및 중간 생성물들

3. 파일 명명 규칙
    - 매니페스트: {식별자}_{타입}.json
    - 오디오: {식별자}_{타입}.mp3
    - 타이밍: {식별자}_{타입}.json
    - 타임라인: {식별자}_{타입}.json
    - 비디오: {프로젝트명}_{타입}.mp4
    - 최종 비디오: {프로젝트명}.mp4

4. 디렉토리 구조
    output/
        {프로젝트명}/
            {식별자}/
            manifest/ (매니페스트 파일들)
            mp3/ (오디오 파일들)
            timing/ (타이밍 정보 파일들)
            subtitles/ (자막 이미지 파일들)
            timeline/ (타임라인 파일들)
            mp4/ (비디오 파일들)


인트로/엔딩과 회화/대화의 감정 표현 차별화 및 쉼표 휴지 기능을 구현하기 위한 TODO를 만들어드리겠습니다.
스크립트 타입별 감정 표현 시스템 설계 및 구현
인트로/엔딩: 자연스러운 일상 대화용 감정 표현 구현 (친근함, 따뜻함)
회화/대화: 정확한 발음 중심 감정 표현 구현 (명확함, 교육적)
쉼표 휴지 시스템 구현 - SSML break 태그 사용
휴지 시간을 타이밍 계산에 정확히 반영하는 로직 구현
감정별 SSML 생성 함수 구현 (rate, pitch, volume, emphasis)
AudioGenerator에 감정 표현 및 휴지 기능 통합
휴지 포함 오디오와 타이밍 파일 동기화 검증 시스템
UI에 감정 선택 옵션 추가 (선택사항)
감정 표현 및 휴지 기능 테스트 및 검증
�� 감정 표현 및 쉼표 휴지 기능 구현 TODO
�� 1단계: 감정 표현 시스템 설계
스크립트 타입별 감정 표현 시스템 설계 및 구현
인트로/엔딩: 자연스러운 일상 대화용 감정 표현 구현 (친근함, 따뜻함)
회화/대화: 정확한 발음 중심 감정 표현 구현 (명확함, 교육적)
🎵 2단계: 쉼표 휴지 시스템
쉼표 휴지 시스템 구현 - SSML break 태그 사용
휴지 시간을 타이밍 계산에 정확히 반영하는 로직 구현
�� 3단계: 기술적 구현
감정별 SSML 생성 함수 구현 (rate, pitch, volume, emphasis)
AudioGenerator에 감정 표현 및 휴지 기능 통합
✅ 4단계: 검증 및 테스트
휴지 포함 오디오와 타이밍 파일 동기화 검증 시스템
감정 표현 및 휴지 기능 테스트 및 검증
�� 5단계: UI 개선 (선택사항)
UI에 감정 선택 옵션 추가
�� 구현 우선순위
높은 우선순위 (핵심 기능)
감정별 SSML 생성 함수 - 기본 감정 표현 구현
쉼표 휴지 시스템 - 자연스러운 대화 표현
타이밍 동기화 - 정확한 비디오-오디오 매칭
중간 우선순위 (시스템 통합)
AudioGenerator 통합 - 기존 시스템과 연동
동기화 검증 - 품질 보장
낮은 우선순위 (사용자 경험)
UI 감정 선택 - 사용자 커스터마이징
🔍 기술적 세부사항
감정 표현 매핑
휴지 시간 설정
이제 첫 번째 TODO부터 시작하시겠습니까? 어떤 부분부터 구현하고 싶으신지 알려주세요!

 SSML에 화자를 넣지 말고, Google TTS 를 호출 할 때 화자를 넣어서 호출 하는 방식으로  
 감정 표현만 SSML 에 넣고 화자는 나중에 포함해서 요청 하는 형식으로 만들어


프로그램 정리 (v)

 타임라인 생성 버튼을 없애고 함수도 정리 해 줘.
 비디오 렌더링 버튼을 없애고 타이밍 기반 렌더링을 비디오 렌더링으로 이름을 바꾸고 칼라도 다른 버튼과 갖게 해 줘.
